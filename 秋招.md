## nowcoder

### One

1、数组 ：[ 二维数组中的查找](https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&tqId=11154&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
public static boolean Find(int target, int [][] array) {
    int rows = array.length, cols = array[0].length;
    int r = 0, c = cols - 1;
    //从右上角开始找
    while(r < rows && c >= 0) {
        if(target < array[r][c]) {
            c--;
        } else if(target > array[r][c]) {
            r++;
        } else {
            return true;
        }
    }
    return false;
 }
```

2、字符串：[ 替换空格](https://www.nowcoder.com/practice/4060ac7e3e404ad1a894ef3e17650423?tpId=13&tqId=11155&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
public String replaceSpace(StringBuffer str) {
    StringBuffer res = new StringBuffer();
    for(int i = 0; i < str.length(); i++) {
        char c = str.charAt(i);
        if(c == ' ') {
            res.append("%20");
        } else {
            res.append(c);
        }
    }
    return res.toString();
 }
```

3、链表：[从尾到头打印链表](https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&tqId=11156&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
import java.util.*;
public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
    ArrayList<Integer> res = new ArrayList<>();
    Stack<Integer> stack = new Stack<>();
    while(listNode != null) {
        stack.push(listNode.val);
        listNode = listNode.next;
    }
    while(!stack.isEmpty()) {
        res.add(stack.pop());
    }
    return res;
 }
```

4、树：[ 重建二叉树](https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&tqId=11157&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
public TreeNode reConstructBinaryTree(int [] pre,int [] in) {
    if(pre == null || pre.length == 0 || pre.length != in.length) {
        return null;
    }
    return reConstructBinaryTree(pre, 0, pre.length - 1,
                                 in, 0, in.length - 1);
}
public TreeNode reConstructBinaryTree(int[] pre, int startPre, int endPre,
                                         int[] in, int startIn, int endIn) {
    if(startPre > endPre || startIn > endIn) {
        return null;
    }
    int rootVal = pre[startPre];
    int rootIndex;
    for(rootIndex = 0; rootIndex < in.length; rootIndex++) {
        if(in[rootIndex] == rootVal) {
            break;
        }
    }
    int leftLength = rootIndex - startIn;
    TreeNode root = new TreeNode(rootVal);
    root.left = reConstructBinaryTree(pre, startPre + 1, startPre + leftLength,
                                      in, startIn, rootIndex - 1);
    root.right = reConstructBinaryTree(pre, startPre + leftLength + 1, endPre,
                                       in, rootIndex + 1, endIn);
    return root;
}
```

5、栈和队列：[ 用两个栈实现队列](https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&tqId=11158&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
import java.util.Stack;
public class Solution {
    Stack<Integer> stack1 = new Stack<Integer>();
    Stack<Integer> stack2 = new Stack<Integer>();
    //栈1用来push
    //栈2用来pop
    public void push(int node) {
        stack1.push(node);
    }
    
    public int pop() {
        if(stack2.isEmpty()) {
            while(!stack1.isEmpty()) {
                stack2.push(stack1.pop());
            }
        }
        return stack2.pop();
    }
}
```

6、查找和排序：[ 旋转数组的最小数字](https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&tqId=11159&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
import java.util.ArrayList;
public int minNumberInRotateArray(int [] array) {
    if(array.length == 0) {
        return 0;
    }
    int num = array[0], index = 0;
    for(int i = 1; i < array.length; i++) {
        if(array[i] < num) {
            index = i;
            break;
        }
    }
    return array[index];
}
```

7、递归和循环 ：[斐波那契数列](https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=13&tqId=11160&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
public int Fibonacci(int n) {
    if(n == 0) {
        return 0;
    }
    if(n == 1) {
        return 1;
    }
    return Fibonacci(n - 1) + Fibonacci(n - 2);
}
```

8、递归和循环 ：[ 跳台阶](https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&tqId=11161&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
public int JumpFloor(int target) {
    if(target == 1 || target == 2) {
        return target;
    }
    return JumpFloor(target - 1) + JumpFloor(target - 2);
}
```

9、递归和循环 ：[变态跳台阶](https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&tqId=11162&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
 public int JumpFloorII(int target) {
     if(target == 1 || target == 2) {
         return target;
     }
     return 2 * JumpFloorII(target - 1);
 }
```

10、递归和循环 ：[矩形覆盖](https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&tqId=11163&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
public int RectCover(int target) {
    if(target == 0) {
        return 0;
    } else if(target ==  1 || target == 2) {
        return target;
    } else {
        return RectCover(target - 1) + RectCover(target - 2);
    }
}
```

11、位运算 ：[二进制中1的个数](https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8?tpId=13&tqId=11164&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
public int NumberOf1(int n) {
    int count = 0;
    char[] chars = Integer.toBinaryString(n).toCharArray();
    for(int i = 0; i < chars.length; i++) {
        if(chars[i] == '1') {
            count++;
        }
    }
    return count;
}
```

12、代码的完整性 ：[数值的整数次方](https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00?tpId=13&tqId=11165&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
 public double Power(double base, int exponent) {
     double sum = 0, temp = base;
     if(exponent == 0) {
         return 1;
     }
     if(exponent == 1) {
         return base;
     }
     if(exponent > 1) {
         for(int i = 1; i < exponent; i++) {
             sum = temp * base;
             temp = sum;
         }
     } 
     if(exponent < 1) {
         for(int i = -1; i > exponent; i--) {
             sum = temp * base;
             temp = sum;
         }
         sum = 1 / sum;
     }
     return sum;
 }
```

13、代码的完整性 ：[ 调整数组顺序使奇数位于偶数前面](https://www.nowcoder.com/practice/beb5aa231adc45b2a5dcc5b62c93f593?tpId=13&tqId=11166&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
public void reOrderArray(int [] array) {
    int oddCount = 0;
    for(int num : array) {
        if(num % 2 == 1) {
            oddCount++;
        }
    }
    int[] copy = array.clone();
    int i = 0, j = oddCount;
    for(int num : copy) {
        if(num % 2 == 1) {
            array[i++] = num;
        } else {
            array[j++] = num;
        }
    }
}
```

14、代码的鲁棒性 ：[链表中倒数第k个结点](https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?tpId=13&tqId=11167&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
public ListNode FindKthToTail(ListNode head,int k) {
    ListNode cur = head;
    int length = 0;
    while(cur != null) {
        length++;
        cur = cur.next;
    }
    if(length == 0 || length < k) {
        return null;
    }
    cur = head;
    for(int i = 0; i < length - k; i++) {
        cur = cur.next;
    }
    return cur;
}
```

15、 代码的鲁棒性 ：[ 反转链表](https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=13&tqId=11168&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
public ListNode ReverseList(ListNode head) {
    ListNode newHead = null;
    while(head != null) {
        ListNode temp = head.next;
        head.next = newHead;
        newHead = head;
        head = temp;
    }
    return newHead;
}
```

16、代码的鲁棒性 ：[合并两个排序的链表](https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&tqId=11169&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
public ListNode Merge(ListNode list1,ListNode list2) {
    ListNode dummyHead = new ListNode(-1);
    ListNode cur = dummyHead;
    while(list1 != null && list2 != null) {
        if(list1.val <= list2.val) {
            cur.next = list1;
            list1 = list1.next;
            cur = cur.next;
        } else if(list1.val > list2.val) {
            cur.next = list2;
            list2 = list2.next;
            cur = cur.next;
        }
    }
    if(list1 != null) {
        cur.next = list1;
    }
    if(list2 != null) {
        cur.next = list2;
    }
    return dummyHead.next;
}
```

17、 代码的鲁棒性 ：[树的子结构](https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88?tpId=13&tqId=11170&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
public boolean HasSubtree(TreeNode root1,TreeNode root2) {
    boolean res = false;
    if(root1 != null && root2 != null) {
        if(root1.val == root2.val) {
            res = isSubTree(root1, root2);
        } 
        if(!res) {
            res = HasSubtree(root1.left, root2);
        }
        if(!res) {
            res = HasSubtree(root1.right, root2);
        }
    }
    return res;
}
public boolean isSubTree(TreeNode node1,TreeNode node2) {
    if(node2 == null) {
        return true;
    }
    if(node1 == null) {
        return false;
    }
    if(node1.val != node2.val) {
        return false;
    }
    return isSubTree(node1.left, node2.left) &&
        isSubTree(node1.right, node2.right);
}
```

18、面试思路 ：[二叉树的镜像](https://www.nowcoder.com/practice/564f4c26aa584921bc75623e48ca3011?tpId=13&tqId=11171&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
public void Mirror(TreeNode root) {
    if(root == null) {
        return;
    }
    swap(root);
    Mirror(root.left);
    Mirror(root.right);
}
public void swap(TreeNode root) {
    TreeNode temp = root.left;
    root.left = root.right;
    root.right = temp;
}
```

19、画图让抽象形象化：[顺时针打印矩阵](https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a?tpId=13&tqId=11172&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
import java.util.ArrayList;
public ArrayList<Integer> printMatrix(int [][] matrix) {
     ArrayList<Integer> res = new ArrayList<>();
     int right = matrix[0].length - 1, down = matrix.length - 1;
     int left = 0, up = 0;
     while(left <= right && up <= down) {
         for(int i = left; i <= right; i++) {
             res.add(matrix[left][i]);
         }
         up++;
         for(int i = up; i <= down; i++) {
             res.add(matrix[i][right]);
         }
         right--;
         if(up - 1 != down) {
             for(int i = right; i >= left; i--) {
                 res.add(matrix[down][i]);
             }
             down--;
         }
         if(left - 1 != right) {
             for(int i = down; i >= up; i--) {
                 res.add(matrix[i][left]);
             }
             left++;
         }
     }
     return res;
 }
```

20、 举例让抽象具体化 ：[ 包含min函数的栈](https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49?tpId=13&tqId=11173&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
import java.util.Stack;
public class Solution {
    Stack<Integer> stack = new Stack<>();
    Stack<Integer> stack_min = new Stack<>();
    public void push(int node) {
        stack.push(node);
        if(stack_min.isEmpty() || stack_min.peek() > node) {
            stack_min.push(node);
        } else {
            stack_min.push(stack_min.peek());
        }
    }
    
    public void pop() {
        if(stack.isEmpty()) {
            return;
        }
        stack.pop();
        stack_min.pop();
    }
    
    public int top() {
        if(stack.isEmpty()) {
            return -1;
        }
        return stack.peek();
    }
    
    public int min() {
        if(stack_min.isEmpty()) {
            return -1;
        }
        return stack_min.peek();
    }
}
```

### Two

21、举例让抽象具体化 ：[栈的压入、弹出序列](https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&tqId=11174&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
import java.util.*;
public boolean IsPopOrder(int [] pushA,int [] popA) {
    if(pushA == null || pushA.length == 0 || pushA.length != popA.length) {
        return false;
    }
    Stack<Integer> stack = new Stack<>();
    int j = 0;
    for(int i = 0; i < pushA.length; i++) {
        stack.push(pushA[i]);
        while(j < pushA.length && stack.peek() == popA[j]) {
            stack.pop();
            j++;
        }
    }
    if(stack.isEmpty()) {
        return true;
    }
    return false;
}
```

22、举例让抽象具体化 ：[从上往下打印二叉树](https://www.nowcoder.com/practice/7fe2212963db4790b57431d9ed259701?tpId=13&tqId=11175&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
import java.util.*;
public ArrayList<Integer> PrintFromTopToBottom(TreeNode root) {
    ArrayList<Integer> res = new ArrayList<>();
    if(root == null) {
        return res;
    }
    Queue<TreeNode> queue = new LinkedList<>();
    queue.add(root);
    while(!queue.isEmpty()) {
        TreeNode cur = queue.remove();
        res.add(cur.val);
        if(cur.left != null) {
            queue.add(cur.left);
        }
        if(cur.right != null) {
            queue.add(cur.right);
        }
    }
    return res;
}
```

23、 举例让抽象具体化 ：[ 二叉搜索树的后序遍历序列](https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd?tpId=13&tqId=11176&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
public class Solution {
    public boolean VerifySquenceOfBST(int [] sequence) {
        if(sequence == null || sequence.length == 0) {
            return false;
        }
        return isSequenceOfBST(sequence, 0, sequence.length - 1);
    }
    
    public boolean isSequenceOfBST(int[] sequence, int start, int end) {
        if(start >= end) {
            return true;
        }
        int rootVal = sequence[end];
        int i;
        for(i = start; i < end; i++) {
            if(sequence[i] > rootVal) {
                break;
            }
        }
        for(int j = i; j < end; j++) {
            if(sequence[j] < rootVal) {
                return false;
            }
        }
        return isSequenceOfBST(sequence, start, i - 1) && isSequenceOfBST(sequence, i, end - 1);
    }
}
```

24、 举例让抽象具体化 ：[二叉树中和为某一值的路径](https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca?tpId=13&tqId=11177&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
import java.util.*;
ArrayList<ArrayList<Integer>> res = new ArrayList<>();
ArrayList<Integer> list = new ArrayList<>();
public ArrayList<ArrayList<Integer>> FindPath(TreeNode root,int target) {
    if(root == null) {
        return res;
    }
    list.add(root.val);
    target -= root.val;
    if(target == 0 && root.left == null && root.right == null) {
        res.add(new ArrayList<>(list));
    }
    FindPath(root.left, target);
    FindPath(root.right, target);
    list.remove(list.size() - 1);
    return res;
}
```

25、 分解让复杂问题简单 ：[复杂链表的复制](https://www.nowcoder.com/practice/f836b2c43afc4b35ad6adc41ec941dba?tpId=13&tqId=11178&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

![](img\复制.PNG)

```java
public class Solution {
    public RandomListNode Clone(RandomListNode pHead) {
        if(pHead == null) {
            return null;
        }
        RandomListNode currentNode = pHead;
        //1、复制每个结点，如复制A到A1，并且把A1插到A后
        while(currentNode != null) {
            RandomListNode cloneNode = new RandomListNode(currentNode.label);
            RandomListNode next = currentNode.next;
            currentNode.next = cloneNode;
            cloneNode.next = next;
            currentNode = next;
        }
        //2、将结点的Random指针赋给新结点，A1.random = A.random.next
        currentNode = pHead;
        while(currentNode != null) {
            currentNode.next.random = currentNode.random == null ? null : currentNode.random.next;
            currentNode = currentNode.next.next;
        }
        //3、拆分链表
        currentNode = pHead;
        RandomListNode pCloneHead = currentNode.next;
        while(currentNode != null) {
            RandomListNode cloneNode = currentNode.next;
            currentNode.next = cloneNode.next;
            cloneNode.next = cloneNode.next == null ? null : cloneNode.next.next;
            currentNode = currentNode.next;
        }
        return pCloneHead;
    }
}
```

26、 分解让复杂问题简单 ：[ 二叉搜索树与双向链表](https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=13&tqId=11179&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
TreeNode pLast = null;//指向双向链表表尾
public TreeNode Convert(TreeNode pRootOfTree) {//返回双向链表表头
    if(pRootOfTree == null) {
        return null;
    }
    TreeNode head = Convert(pRootOfTree.left);
    if(head == null) {
        head = pRootOfTree;
    }
    pRootOfTree.left = pLast;
    if(pLast != null) {
        pLast.right = pRootOfTree;
    }
    pLast = pRootOfTree;
    Convert(pRootOfTree.right);
    return head;
}
```

27、分解让复杂问题简单 ：[字符串的排列](https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7?tpId=13&tqId=11180&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

![](img\permute.png)

```java
import java.util.*;
public class Solution {
    public ArrayList<String> Permutation(String str) {
        ArrayList<String> res = new ArrayList<>();
        if(str == null || str.length() == 0) {
            return res;
        }
        char[] chars = str.toCharArray();
        Arrays.sort(chars);
        boolean[] isVisited = new boolean[chars.length];
        StringBuffer sb = new StringBuffer();
        PermutationHelper(res, sb, isVisited, chars);
        return res;
    }
    public void PermutationHelper(ArrayList<String> res, StringBuffer sb, 
                                  boolean[] isVisited, char[] chars) {
        if(sb.length() == chars.length) {
            res.add(new StringBuffer(sb).toString());
        }
        for(int i = 0; i < chars.length; i++) {
            if(i != 0 && chars[i] == chars[i - 1] && !isVisited[i - 1]) {
                continue;
            }
            if(isVisited[i]) {
                continue;
            }
            sb.append(chars[i]);
            isVisited[i] = true;
            PermutationHelper(res, sb, isVisited, chars);
            sb.deleteCharAt(sb.length() - 1);
            isVisited[i] = false;
        }
    }
}
```

28、时间效率 ：[ 数组中出现次数超过一半的数字](https://www.nowcoder.com/practice/e8a1b01a2df14cb2b228b30ee6a92163?tpId=13&tqId=11181&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
import java.util.*;
public int MoreThanHalfNum_Solution(int [] array) {
    Map<Integer, Integer> map = new HashMap<>();
    for(int num : array) {
        if(map.containsKey(num)) {
            map.put(num, map.get(num) + 1);
        } else {
            map.put(num, 1);
        }
    }
    for(int num : array) {
        if(map.get(num) > array.length / 2) {
            return num;
        }
    }
    return 0;
}
```

29、时间效率 ：[最小的K个数](https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=13&tqId=11182&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
import java.util.*;
public ArrayList<Integer> GetLeastNumbers_Solution(int [] input, int k) {
    ArrayList<Integer> res = new ArrayList<>();
    Arrays.sort(input);
    if(input == null || input.length == 0 || input.length < k) {
        return res;
    }
    for(int i = 0; i < k; i++) {
        res.add(input[i]);
    }
    return res;
}
```

30、 时间效率 ：[ 连续子数组的最大和](https://www.nowcoder.com/practice/459bd355da1549fa8a49e350bf3df484?tpId=13&tqId=11183&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
public int FindGreatestSumOfSubArray(int[] array) {
    int preSum = array[0], maxSum = array[0];
    for(int i = 1; i < array.length; i++) {
        if(preSum > 0) {
            preSum += array[i];
        } else {
            preSum = array[i];
        }
        maxSum = Integer.max(preSum, maxSum);
    }
    return maxSum;
}
```

31、时间效率 ：[ 整数中1出现的次数（从1到n整数中1出现的次数）](https://www.nowcoder.com/practice/bd7f978302044eee894445e244c7eee6?tpId=13&tqId=11184&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
public int NumberOf1Between1AndN_Solution(int n) {
    int count = 0;
    for(int i = 1; i <= n; i++) {
        char[] chars = String.valueOf(i).toCharArray();
        for(int j = 0; j < chars.length; j++) {
            if(chars[j] == '1') {
                count++;
            }
        }
    }
    return count;
}
```

32、时间效率 ：[把数组排成最小的数](https://www.nowcoder.com/practice/8fecd3f8ba334add803bf2a06af1b993?tpId=13&tqId=11185&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
import java.util.*;
public String PrintMinNumber(int [] numbers) {
    ArrayList<Integer> list = new ArrayList<>();
    for(int num : numbers) {
        list.add(num);
    }
    Collections.sort(list, new Comparator<Integer>() {
        public int compare(Integer o1, Integer o2) {
            String str1 = o1 + "" + o2;
            String str2 = o2 + "" + o1;
            return str1.compareTo(str2);
        }
    });
    StringBuffer res = new StringBuffer();
    for(int i = 0; i < list.size(); i++) {
        res.append(list.get(i));
    }
    return res.toString();
}
```

33、 时间空间效率的平衡 ：[丑数](https://www.nowcoder.com/practice/6aa9e04fc3794f68acf8778237ba065b?tpId=13&tqId=11186&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
import java.util.*;
public int GetUglyNumber_Solution(int index) {
    if(index == 0) {
        return 0;
    }
    int i2 = 0, i3 = 0, i5 = 0;
    ArrayList<Integer> list = new ArrayList<>();
    list.add(1);
    while(list.size() < index) {
        int m2 = list.get(i2) * 2;
        int m3 = list.get(i3) * 3;
        int m5 = list.get(i5) * 5;
        int min = Integer.min(m2, Integer.min(m3, m5));
        list.add(min);
        if(m2 == min) {
            i2++;
        }
        if(m3 == min) {
            i3++;
        }
        if(m5 == min) {
            i5++;
        }
    }
    return list.get(list.size() - 1);
}
```

34、 时间空间效率的平衡 ：[ 第一个只出现一次的字符位置](https://www.nowcoder.com/practice/1c82e8cf713b4bbeb2a5b31cf5b0417c?tpId=13&tqId=11187&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
import java.util.*;
public int FirstNotRepeatingChar(String str) {
     if(str == null || str.length() == 0) {
         return -1;
     }
     Map<Character, Integer> map = new HashMap<>();
     for(int i = 0; i < str.length(); i++) {
         char c = str.charAt(i);
         if(map.containsKey(c)) {
             map.put(c, map.get(c) + 1);
         } else {
             map.put(c, 1);
         }
     }
     for(int i = 0; i < str.length(); i++) {
         char c = str.charAt(i);
         if(map.get(c) == 1) {
             return i;
         }
     }
     return -1;
 }
```

35、 时间空间效率的平衡 ：[数组中的逆序对](https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=13&tqId=11188&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
public class Solution {
    public int InversePairs(int [] array) {
        if(array == null || array.length == 0) {
            return 0;
        }
        int[] copy = new int[array.length];
        int count = InversePairsHelper(array, copy, 0, array.length - 1);
        return count % 1000000007;
    }
    public int InversePairsHelper(int[] array, int[] copy, int low, int high) {
        if(low == high) {
            return 0;
        }
        int mid = low + (high - low) / 2;
        int leftCount = InversePairsHelper(array, copy, low, mid);
        int rightCount = InversePairsHelper(array, copy, mid + 1, high);
        int i = mid, j = high;
        int count = 0;
        int index = high;
        while (i >= low && j >= mid + 1) {
            if(array[i] > array[j]) {
                count += j - mid;
                copy[index--] = array[i--];
                if(count >= 1000000007) {
                    count %= 1000000007;
                }
            } else {
                copy[index--] = array[j--];
            }
        }
        for(; i >= low; i--) {
            copy[index--] = array[i];
        }
        for(; j >= mid + 1; j--) {
            copy[index--] = array[j];
        }
        for(int k = low; k <= high; k++) {
            array[k] = copy[k];
        }
        return (leftCount + rightCount + count) % 1000000007;
    }
}
```

36、 时间空间效率的平衡 ：[两个链表的第一个公共结点](https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=13&tqId=11189&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
import java.util.*;
public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) {
    Set<ListNode> set = new HashSet<>();
    while(pHead1 != null) {
        set.add(pHead1);
        pHead1 = pHead1.next;
    }
    while(pHead2 != null) {
        if(set.contains(pHead2)) {
            return pHead2;
        }
        pHead2 = pHead2.next;
    }
    return null;
}
```

37、知识迁移能力 ：[ 数字在排序数组中出现的次数](https://www.nowcoder.com/practice/70610bf967994b22bb1c26f9ae901fa2?tpId=13&tqId=11190&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
public class Solution {
    public int GetNumberOfK(int [] array , int k) {
        if(array == null || array.length == 0) {
            return 0;
        }
        int first = firstNumberOfK(array, k, 0, array.length - 1);
        int last = lastNumberOfK(array, k, 0, array.length - 1);
        if(first != -1 && last != -1) {
            return (last - first + 1);
        } else {
            return 0;
        }
    }
    public int firstNumberOfK(int [] array, int k, int low, int high) {
        int mid = 0;
        while(low <= high) {
            mid = low + (high - low) / 2;
            if(array[mid] == k) {
                if(mid > low && array[mid] != array[mid - 1] || mid == low) {
                    return mid;
                } else {
                    high = mid - 1;
                }
            } else if(array[mid] > k) {
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
        return -1;
    }
    public int lastNumberOfK(int [] array, int k, int low, int high) {
        int mid = 0;
        while(low <= high) {
            mid = low + (high - low) / 2;
            if(array[mid] == k) {
                if(mid != high && array[mid] != array[mid + 1] || mid == high) {
                    return mid;
                } else {
                    low = mid + 1;
                }
            } else if(array[mid] < k) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }
        return -1;
    }
}
```

38、知识迁移能力 ：[二叉树的深度](https://www.nowcoder.com/practice/435fb86331474282a3499955f0a41e8b?tpId=13&tqId=11191&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
 public int TreeDepth(TreeNode root) {
     if(root == null) {
         return 0;
     }
     int leftDepth = TreeDepth(root.left);
     int rightDepth = TreeDepth(root.right);
     return Integer.max(leftDepth, rightDepth) + 1;
 }
```

39、知识迁移能力 ：[平衡二叉树](https://www.nowcoder.com/practice/8b3b95850edb4115918ecebdf1b4d222?tpId=13&tqId=11192&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
public boolean IsBalanced_Solution(TreeNode root) {
        if(root == null) {
            return true;
        }
        if(Math.abs(height(root.left) - height(root.right)) > 1) {
            return false;
        }
        return IsBalanced_Solution(root.left) && IsBalanced_Solution(root.right);
    }
public int height(TreeNode root) {
    if(root == null) {
        return 0;
    }
    return Integer.max(height(root.left), height(root.right)) + 1; 
}
```

40、知识迁移能力 ：[数组中只出现一次的数字](https://www.nowcoder.com/practice/e02fdb54d7524710a7d664d082bb7811?tpId=13&tqId=11193&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
import java.util.*;
public void FindNumsAppearOnce(int [] array,int num1[] , int num2[]) {
    Map<Integer, Integer> map = new HashMap<>();
    for(int num : array) {
        if(map.containsKey(num)) {
            map.put(num, map.get(num) + 1);
        } else {
            map.put(num, 1);
        }
    }
    int[] res = new int[2];
    int index = 0;
    for(int num : array) {
        if(map.get(num) == 1) {
            res[index++] = num;
        }
        if(index >= 2) {
            break;
        }
    }
    num1[0] = res[0];
    num2[0] = res[1];
}
```

### Three

41、知识迁移能力 ：[和为S的连续正数序列](https://www.nowcoder.com/practice/c451a3fd84b64cb19485dad758a55ebe?tpId=13&tqId=11194&tPage=3&rp=3&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
import java.util.ArrayList;
 public ArrayList<ArrayList<Integer> > FindContinuousSequence(int sum) {
     ArrayList<ArrayList<Integer>> res = new ArrayList<>();
     ArrayList<Integer> temp = null;
     for(int i = 1; i < sum; i++) {
         temp = new ArrayList<>();
         int j = i, curSum = i;
         temp.add(j);
         while(curSum < sum) {
             j++;
             temp.add(j);
             curSum += j;
         }
         if(curSum == sum) {
             res.add(temp);
         }
     }
     return res;
 }
```

42、知识迁移能力 ：[和为S的两个数字](https://www.nowcoder.com/practice/390da4f7a00f44bea7c2f3d19491311b?tpId=13&tqId=11195&tPage=3&rp=3&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
import java.util.ArrayList;
public ArrayList<Integer> FindNumbersWithSum(int [] array,int sum) {
    ArrayList<Integer> res = new ArrayList<>();
    if(array == null || array.length == 0) {
        return res;
    }
    int left = 0, right = array.length - 1;
    while(left < right) {
        if(array[left] + array[right] == sum) {
            res.add(array[left]);
            res.add(array[right]);
            return res;
        } else if(array[left] + array[right] < sum) {
            left++;
        } else {
            right--;
        }
    }
    return res;
}
```

43、 知识迁移能力 ：[左旋转字符串](https://www.nowcoder.com/practice/12d959b108cb42b1ab72cef4d36af5ec?tpId=13&tqId=11196&tPage=3&rp=3&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
public String LeftRotateString(String str,int n) {
    StringBuffer res = new StringBuffer();
    StringBuffer temp = new StringBuffer();
    for(int i = 0; i < str.length(); i++) {
        char c = str.charAt(i);
        if(i < n) {
            temp.append(c);
        } else {
            res.append(c);
        }
    }
    res.append(temp);
    return res.toString();
}
```

44、知识迁移能力 ：[翻转单词顺序列](https://www.nowcoder.com/practice/3194a4f4cf814f63919d0790578d51f3?tpId=13&tqId=11197&tPage=3&rp=3&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
public String ReverseSentence(String str) {
    StringBuffer res = new StringBuffer();
    if("".equals(str.trim())) {
        return str;
    }
    String[] strs = str.split(" ");
    for(int i = strs.length - 1; i >= 0; i--) {
        res.append(strs[i]).append(" ");
    }
    return res.toString().trim();
}
```

45、 抽象建模能力 ：[扑克牌顺子](https://www.nowcoder.com/practice/762836f4d43d43ca9deb273b3de8e1f4?tpId=13&tqId=11198&tPage=3&rp=3&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
import java.util.*;
public boolean isContinuous(int [] numbers) {
     if(numbers == null || numbers.length < 5) {
         return false;
     }
     Arrays.sort(numbers);
     int countZero = 0, totalGap = 0;
     for(int i = 0; i < numbers.length; i++) {
         if(numbers[i] == 0) {
             countZero++;
             continue;
         }
         if(i < numbers.length - 1) {
             int gap = numbers[i + 1] - numbers[i] - 1;
             if(gap < 0) {
                 return false;
             }
             totalGap += gap;
         }
     }
     if(totalGap > countZero) {
         return false;
     }
     return true;
 }
```

46、抽象建模能力 ：[孩子们的游戏(圆圈中最后剩下的数)](https://www.nowcoder.com/practice/f78a359491e64a50bce2d89cff857eb6?tpId=13&tqId=11199&tPage=3&rp=3&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
public int LastRemaining_Solution(int n, int m) {
    if(n == 0) {
        return -1;
    }
    if(n == 1) {
        return 0;
    }
    return (LastRemaining_Solution(n - 1, m) + m) % n;
}
```

47、发散思维能力 ：[求1+2+3+...+n](https://www.nowcoder.com/practice/7a0da8fc483247ff8800059e12d7caf1?tpId=13&tqId=11200&tPage=3&rp=3&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
public int Sum_Solution(int n) {
    return (int)(Math.pow(n, 2) + n) >> 1;
}
```

48、发散思维能力 ：[ 不用加减乘除做加法](https://www.nowcoder.com/practice/59ac416b4b944300b617d4f7f111b215?tpId=13&tqId=11201&tPage=3&rp=3&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
public int Add(int num1,int num2) {
    while(num2 != 0) {
        int sum = num1 ^ num2;
        int carry = (num1 & num2) << 1;
        num1 = sum;
        num2 = carry;
    }
    return num1;
}
```

49、综合 ：[ 把字符串转换成整数](https://www.nowcoder.com/practice/1277c681251b4372bdef344468e4f26e?tpId=13&tqId=11202&tPage=3&rp=3&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
public int StrToInt(String str) {
    if(str == null || str.length() == 0) {
        return 0;
    }
    int symbol = 0, sum = 0;
    if(str.charAt(0) == '-' || str.charAt(0) == '+') {
        symbol = 1;
    }
    for(int i = symbol; i < str.length(); i++) {
        char c = str.charAt(i);
        if(c >= '0' && c <= '9') {
            sum = (sum * 10) + c - '0';
        } else {
            return 0;
        }
    }
    if(str.charAt(0) == '-') {
        sum *= -1;
    }
    return sum;
}
```

50、 数组 ：[数组中重复的数字](https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8?tpId=13&tqId=11203&tPage=3&rp=3&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
import java.util.*;
public boolean duplicate(int numbers[],int length,int [] duplication) {
     if(numbers == null || length == 0) {
         return false;
     }
     Map<Integer, Integer> map = new HashMap<>();
     for(int num : numbers) {
         if(map.containsKey(num)) {
             map.put(num, map.get(num) + 1);
         } else {
             map.put(num, 1);
         }
     }
     for(int num : numbers) {
         if(map.get(num) > 1) {
             duplication[0] = num;
             return true;
         }
     }
     return false;
 }
```

51、数组 ：[构建乘积数组](https://www.nowcoder.com/practice/94a4d381a68b47b7a8bed86f2975db46?tpId=13&tqId=11204&tPage=3&rp=3&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
public int[] multiply(int[] A) {
    int[] B = new int[A.length];
    B[0] = 1;
    //下三角
    for(int i = 1; i < B.length; i++) {
        B[i] = B[i - 1] * A[i - 1];
    }
    //上三角
    int temp = 1;
    for(int i = B.length - 2; i >= 0; i--) {
        temp *= A[i + 1];
        B[i] *= temp;
    }
    return B;
}
```

52、字符串 ：[正则表达式匹配](https://www.nowcoder.com/practice/45327ae22b7b413ea21df13ee7d6429c?tpId=13&tqId=11205&tPage=3&rp=3&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

53、 字符串 ：[表示数值的字符串](https://www.nowcoder.com/practice/6f8c901d091949a5837e24bb82a731f2?tpId=13&tqId=11206&tPage=3&rp=3&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
public boolean isNumeric(char[] str) {
    boolean decimal = false, sign = false, hasE = false;
    for(int i = 0; i < str.length; i++) {
        if(str[i] == 'e' || str[i] == 'E') {
            if(hasE) {//不能出现两个E
                return false;
            }
            if(i == str.length - 1) {//e不能出现在结尾
                return false;
            }
            hasE = true;
        } else if(str[i] == '-' || str[i] == '+') {
            if(!sign && i > 0 && str[i - 1] != 'e' && str[i - 1] != 'E') {//第一次出现符号，且不是开头，必须在e后
                return false;
            }
            if(sign && str[i - 1] != 'e' && str[i - 1] != 'E') {//第二次出现e,必须在E后
                return false;
            }
            sign = true;
        } else if(str[i] == '.') {
            if(decimal || hasE) {//不能出现两个小数点,e后不能有小数点
                return false;
            }
            decimal = true;
        } else if(str[i] < '0' || str[i] > '9') {
            return false;
        }
    }
    return true;
}
```

54、字符串 ：[字符流中第一个不重复的字符](https://www.nowcoder.com/practice/00de97733b8e4f97a3fb5c680ee10720?tpId=13&tqId=11207&tPage=3&rp=3&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
import java.util.*;
StringBuffer str = new StringBuffer();
//Insert one char from stringstream
public void Insert(char ch) {
    str.append(ch);
}
//return the first appearence once char in current stringstream
public char FirstAppearingOnce() {
    LinkedHashMap<Character, Integer> map = new LinkedHashMap<>();
    for(int i = 0; i < str.length(); i++) {
        char c = str.charAt(i);
        if(map.containsKey(c)) {
            map.put(c, map.get(c) + 1);
        } else {
            map.put(c, 1);
        }
    }
    char res = '#';
    for(int i = 0; i < str.length(); i++) {
        char c = str.charAt(i);
        if(map.get(c) == 1) {
            res = c;
            break;
        }
    }
    return res;
}
```

55、链表 ：[ 链表中环的入口结点](https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=13&tqId=11208&tPage=3&rp=3&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
public ListNode EntryNodeOfLoop(ListNode pHead) {
    ListNode first = pHead;
    ListNode second = pHead;
    while(first != null && first.next != null) {
        first = first.next;
        second = second.next.next;
        if(first == second) {
            first = pHead;
            while(first != second) {
                first = first.next;
                second = second.next;
            }
            return first;
        }
    }
    return null;
}
```

56、链表 ：[删除链表中重复的结点](https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef?tpId=13&tqId=11209&tPage=3&rp=3&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
 public ListNode deleteDuplication(ListNode pHead) {
     ListNode dummyHead = new ListNode(-1);
     dummyHead.next = pHead;
     ListNode pre = dummyHead;
     ListNode cur = dummyHead.next;
     while(cur != null) {
         if(cur.next != null && cur.val == cur.next.val) {
             while(cur.next != null && cur.val == cur.next.val) {//找出最后一个相同结点
                 cur = cur.next;
             }
             pre.next = cur.next;
             cur = cur.next;
         } else {
             pre = pre.next;
             cur = cur.next;
         }
     }
     return dummyHead.next;
 }
```

57、树 ：[二叉树的下一个结点](https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&tqId=11210&tPage=3&rp=3&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

![](img\next.PNG)

```java
public TreeLinkNode GetNext(TreeLinkNode pNode) {
    if(pNode == null) {
        return null;
    }
    //有右子树，指针指向右孩子，向左找直到找到最左叶子结点
    while(pNode.right != null) {
        pNode = pNode.right;
        while(pNode.left != null) {
            pNode = pNode.left;
        }
        return pNode;
    }
    //不是结尾
    while(pNode.next != null) {
        TreeLinkNode pRoot = pNode.next;
        if(pRoot.left == pNode) {
            return pRoot;
        }
        pNode = pRoot;
    }
    return null;
}
```

58、树 ：[ 对称的二叉树](https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb?tpId=13&tqId=11211&tPage=3&rp=3&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
 boolean isSymmetrical(TreeNode pRoot) {
        TreeNode mRoot = mirror(pRoot);
        return isSymmetrical(pRoot, mRoot);
    }
boolean isSymmetrical(TreeNode pRoot, TreeNode mRoot) {
    if(pRoot == null && mRoot == null) {
        return true;
    }
    if(pRoot == null || mRoot == null) {
        return false;
    }
    if(pRoot.val == mRoot.val) {
        return isSymmetrical(pRoot.left, mRoot.left) && isSymmetrical(pRoot.right, mRoot.right);
    }
    return false;
}
public TreeNode mirror(TreeNode pRoot) {
    if(pRoot == null) {
        return null;
    }
    TreeNode mRoot = new TreeNode(pRoot.val);
    mRoot.left = mirror(pRoot.right);
    mRoot.right = mirror(pRoot.left);
    return mRoot;
}
```

59、 树 ：[按之字形顺序打印二叉树](https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0?tpId=13&tqId=11212&tPage=3&rp=3&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
import java.util.*;
public ArrayList<ArrayList<Integer> > Print(TreeNode pRoot) {
    ArrayList<ArrayList<Integer>> res = new ArrayList<>();
    ArrayList<Integer> temp = null;
    int layer = 1;
    Stack<TreeNode> s1 = new Stack<>();//s1存奇数
    s1.push(pRoot);
    Stack<TreeNode> s2 = new Stack<>();//s2存偶数
    while(!s1.isEmpty() || !s2.isEmpty()) {
        if(layer % 2 != 0) {//奇数
            temp = new ArrayList<>();
            while(!s1.isEmpty()) {
                TreeNode cur = s1.pop();
                if(cur != null) {
                    temp.add(cur.val);
                    s2.push(cur.left);
                    s2.push(cur.right);
                }
            }
            if(!temp.isEmpty()) {
                res.add(temp);
                layer++;
            }
        } else {
            temp = new ArrayList<>();
            while(!s2.isEmpty()) {
                TreeNode cur = s2.pop();
                if(cur != null) {
                    temp.add(cur.val);
                    s1.push(cur.right);
                    s1.push(cur.left);
                }
            }
            if(!temp.isEmpty()) {
                res.add(temp);
                layer++;
            }
        }
    }
    return res;
}
```

60、 树 ：[把二叉树打印成多行](https://www.nowcoder.com/practice/445c44d982d04483b04a54f298796288?tpId=13&tqId=11213&tPage=3&rp=3&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
import java.util.*;
ArrayList<ArrayList<Integer> > Print(TreeNode pRoot) {
    ArrayList<ArrayList<Integer>> res = new ArrayList<>();
    if(pRoot == null) {
        return res;
    }
    ArrayList<Integer> temp = new ArrayList<>();
    Queue<TreeNode> queue = new LinkedList<>();
    queue.add(pRoot);
    int start = 0, layerSize = queue.size();
    while(!queue.isEmpty()) {
        TreeNode cur = queue.remove();
        if(cur != null) {
            temp.add(cur.val);
            start++;
        }
        if(cur.left != null) {
            queue.add(cur.left);
        }
        if(cur.right != null) {
            queue.add(cur.right);
        }
        if(start == layerSize) {
            res.add(temp);
            temp = new ArrayList<>();
            start = 0;
            layerSize = queue.size();
        }
    }
    return res;
}
```

### Four

61、树 ：[序列化二叉树](https://www.nowcoder.com/practice/cf7e25aa97c04cc1a68c8f040e71fb84?tpId=13&tqId=11214&tPage=4&rp=4&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
public class Solution {
    String Serialize(TreeNode root) {
        StringBuffer res = new StringBuffer();
        if(root == null) {
            res.append("#,");
            return res.toString();
        }
        res.append(root.val).append(",");
        res.append(Serialize(root.left));
        res.append(Serialize(root.right));
        return res.toString();
    }
    int index = -1;
    TreeNode Deserialize(String str) {
        index++;
        TreeNode node = null;
        String[] strs = str.split(",");
        if(!strs[index].equals("#")) {
            node = new TreeNode(Integer.valueOf(strs[index]));
            node.left = Deserialize(str);
            node.right = Deserialize(str);
        }
        return node;
    }
}
```

62、树 ：[二叉搜索树的第k个结点](https://www.nowcoder.com/practice/ef068f602dde4d28aab2b210e859150a?tpId=13&tqId=11215&tPage=4&rp=4&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
import java.util.*;
public class Solution {
    LinkedList<TreeNode> list = new LinkedList<>();
    TreeNode KthNode(TreeNode pRoot, int k) {
        Inorder(pRoot); 
        if(list.size() < k || k == 0) {
            return null;
        }
        return list.get(k - 1);
    }
    void Inorder(TreeNode root) {
        if(root == null) {
            return;
        }
        Inorder(root.left);
        list.add(root);
        Inorder(root.right);
    }
}
```

63、树 ：[数据流中的中位数](https://www.nowcoder.com/practice/9be0172896bd43948f8a32fb954e1be1?tpId=13&tqId=11216&tPage=4&rp=4&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

堆

64、栈和队列 ：[滑动窗口的最大值](https://www.nowcoder.com/practice/1624bc35a45c42c0bc17d17fa0cba788?tpId=13&tqId=11217&tPage=4&rp=4&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

```java
import java.util.*;
public ArrayList<Integer> maxInWindows(int [] num, int size) {
    ArrayList<Integer> res = new ArrayList<>();
    if(num == null || num.length < size || size == 0) {
        return res;
    }
    LinkedList<Integer> qmax = new LinkedList<>();//双端队列，记录当前窗口最大元素的下标
    for(int i = 0; i < num.length; i++) {
        while(!qmax.isEmpty() && num[qmax.peekLast()] < num[i]) {
            qmax.pollLast();
        }
        qmax.add(i);
        //判断队首元素是否过期
        if(qmax.peekFirst() == i - size) {
            qmax.pollFirst();
        }
        if(i >= size - 1) {
            res.add(num[qmax.peekFirst()]);
        }
    }
    return res;
}
```

65、 回溯法 ：[矩阵中的路径](https://www.nowcoder.com/practice/c61c6999eecb4b8f88a98f66b273a3cc?tpId=13&tqId=11218&tPage=4&rp=4&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 

66、回溯法 ：[机器人的运动范围](https://www.nowcoder.com/practice/6e5207314b5241fb83f2329e89fdecc8?tpId=13&tqId=11219&tPage=4&rp=4&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) 



## leetcode

20、[有效的括号](https://leetcode-cn.com/problems/valid-parentheses)    

```java
import java.util.Stack;
public static boolean isValid(String s) {
    Stack<Character> stack = new Stack<>();
    for(int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);
        if(c == '(' || c == '{' || c == '[') {
            stack.push(c);
        } else {
            if(stack.isEmpty()) {
                return false;
            }
            char top = stack.pop();
            if(top == '(' && c != ')') {
                return false;
            }
            if(top == '[' && c != ']') {
                return false;
            }
            if(top == '{' && c != '}') {
                return false;
            }
        }
    }
    return stack.isEmpty();
}
```

387、[字符串中的第一个唯一字符](https://leetcode-cn.com/problems/first-unique-character-in-a-string)     

```java
import java.util.*;
public int firstUniqChar(String s) {
    Map<Character, Integer> map = new LinkedHashMap<>();
    for(int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);
        if(map.containsKey(c)) {
            map.put(c, map.get(c) + 1);
        } else {
            map.put(c, 1);
        }
    }
    for(Map.Entry<Character, Integer> entry : map.entrySet()) {
        if(entry.getValue() == 1) {
            return s.indexOf(entry.getKey());
        }
    }
    return -1;
}
```

203 、[移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements)     

```java
public ListNode removeElements(ListNode head, int val) {
    ListNode dummyHead = new ListNode(-1);
    dummyHead.next = head;
    ListNode prev = dummyHead;
    while(prev.next != null) {
        if(prev.next.val == val) {
            prev.next = prev.next.next;
        } else {
            prev = prev.next;
        }
    }
    return dummyHead.next;
}
```

350、[两个数组的交集 II](https://leetcode-cn.com/problems/intersection-of-two-arrays-ii)     

```java
import java.util.*;
 public int[] intersect(int[] nums1, int[] nums2) {
     TreeMap<Integer, Integer> map = new TreeMap<>();
     for(int num : nums1) {
         if(map.containsKey(num)) {
             map.put(num, map.get(num) + 1);
         } else {
             map.put(num, 1);
         }
     }
     ArrayList<Integer> list = new ArrayList<>();
     for(int num : nums2) {
         if(map.containsKey(num)) {
             list.add(num); 
             map.put(num, map.get(num) - 1);
             if(map.get(num) == 0) {
                 map.remove(num);
             }
         }
     }
     int[] res = new int[list.size()];
     for(int i = 0; i < list.size(); i++) {
         res[i] = list.get(i);
     }
     return res;
 }
```

21、[合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists)     

```java
 public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
     ListNode dummyHead = new ListNode(-1);
     ListNode cur = dummyHead;
     while(l1 != null && l2 != null) {
         if(l1.val <= l2.val) {
             cur.next = l1;
             cur = cur.next;
             l1 = l1.next;
         } else {
             cur.next = l2;
             cur = cur.next;
             l2 = l2.next;
         }
     }
     if(l1 == null) {
         cur.next = l2;
     } 
     if(l2 == null) {
         cur.next = l1;
     }
     return dummyHead.next;
 }
```

347、[前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements)  

```java
import java.util.*;
public List<Integer> topKFrequent(int[] nums, int k) {
    //统计频次
    TreeMap<Integer, Integer> map = new TreeMap<>();
    for(int num : nums) {
        if(map.containsKey(num)) {
            map.put(num, map.get(num) + 1);
        } else {
            map.put(num, 1);
        }
    }

    //维护当前看到的前k个出现频次最高的元素
    PriorityQueue<Integer> pq = new PriorityQueue<>(
        (a, b) -> map.get(a) - map.get(b)
    );
    for(int key : map.keySet()) {
        if(pq.size() < k) {
            pq.add(key);
        } else if(map.get(key) > map.get(pq.peek())) {
            pq.remove();
            pq.add(key);
        }
    }
    LinkedList<Integer> res = new LinkedList<>();
    while(!pq.isEmpty()) {
        res.add(pq.remove());
    }
    return res;
}
```

677 、[键值映射](https://leetcode-cn.com/problems/map-sum-pairs)   

```java
import java.util.*;
private class Node {
    public int val;
    public TreeMap<Character, Node> next;

    public Node(int val) {
        this.val = val;
        next = new TreeMap<>();
    }
    public Node() {
        this(0);
    }
}

private Node root;

/** Initialize your data structure here. */
public MapSum() {
    root = new Node();
}

public void insert(String word, int val) {
    Node cur = root;
    for(int i = 0; i < word.length(); i++) {
        char c = word.charAt(i);
        if(cur.next.get(c) == null) {
            cur.next.put(c, new Node());
        }
        cur = cur.next.get(c);
    }
    cur.val = val;
}

public int sum(String prefix) {
    Node cur = root;
    for(int i =0; i < prefix.length(); i++) {
        char c = prefix.charAt(i);
        if(cur.next.get(c) == null) {
            return 0;
        }
        cur = cur.next.get(c);
    }
    return sum(cur); 
}
private int sum(Node node) {
    int res = node.val;
    for(char c : node.next.keySet()) {
        res += sum(node.next.get(c));
    }
    return res;
}
```

349  、[两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays)     

```java
import java.util.*;
public int[] intersection(int[] nums1, int[] nums2) {
    TreeSet<Integer> set = new TreeSet<>();
    for(int num : nums1) {
        set.add(num);
    }
    ArrayList<Integer> list = new ArrayList<>();
    for(int num : nums2) {
        if(set.contains(num)) {
            list.add(num);
            set.remove(num);
        }
    }
    int[] res = new int[list.size()];
    for(int i = 0; i < list.size(); i++) {
        res[i] = list.get(i);
    }
    return res;
}
```

804 、[唯一摩尔斯密码词](https://leetcode-cn.com/problems/unique-morse-code-words)    

```java
import java.util.*;
public static int uniqueMorseRepresentations(String[] words) {
    String[] codes = {".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."};
    TreeSet<String> set = new TreeSet();
    for(String word:words) {
        StringBuilder res = new StringBuilder();
        for(int i = 0; i < word.length(); i++) {
            res.append(codes[word.charAt(i) - 'a']);
        }
        set.add(res.toString());
    }
    return set.size();
}
```

237 、[删除链表中的节点](https://leetcode-cn.com/problems/delete-node-in-a-linked-list)     

```java
 public void deleteNode(ListNode node) {
     node.val = node.next.val;
     node.next = node.next.next;
 }
```



## 排序算法

![](img\算法分析.jpg)

### 冒泡排序

思想：**交换相邻逆序的元素**，一轮循环后，让未排序的最大元素上浮到右侧。在一轮循环中，如果没有发生交换，那么说明数组已经是有序的，此时可以直接退出。 

```java
public static void sort(int[] num) {
    boolean flag;
    for(int i = 0; i < num.length; i++) {
        flag = false;
        for(int j = 0; j < num.length - i - 1; j++) {
            if(num[j] > num[j + 1]) {
                swap(num, j, j + 1);
                flag = true;
            }
        }
        if(flag == false) {
            break;
        }
    }
}
```

稳定性：稳定，时间复杂度：O（N^2），空间复杂度：1

### 选择排序

思想：从数组中选择最小元素，将它与数组的第一个元素交换位置。 

```java
public static void sort(int[] num) {
    for(int i = 0; i < num.length - 1; i++) {
        int min = i;
        for(int j = i + 1; j < num.length; j++) {
            if(num[j] < num[min]) {
                min = j;
            }
        }
        if(i != min) {
            swap(num, i, min);
        }
    }
}
public static void swap(int[] arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
```

稳定性：不稳定，时间复杂度：O（N^2），空间复杂度：1

### 插入排序

思想：每次都将当前元素插入到左侧已经排序的数组中，使得插入之后左侧数组依然有序。 

```java
public static void sort(int[] num) {
    //第1个数肯定是有序的，从第2个数开始遍历，依次插入有序序列
    for(int i = 1; i < num.length; i++) {
        for(int j = i; j > 0 && num[j] < num[j - 1]; j--) {
            swap(num, j, j - 1);
        }
    }
}
public static void swap(int[] arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
```

稳定性：稳定，时间复杂度：O（N）~ O（N^2） 与初始顺序相关，空间复杂度：1

### 希尔排序

思想：通过交换不相邻的元素，每次可以将逆序数量减少大于 1。 

```java
public static void sort(int[] num) {
    int increment = num.length / 2;
    while(increment > 0) {
        for(int i = increment; i < num.length; i++) {
            for(int j = i; j >= increment && num[j] < num[j - increment]; j -= increment) {
                swap(num, j, j - increment);
            }
        }
        increment /= 2;
    }
}
public static void swap(int[] arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
```

稳定性：不稳定，时间复杂度：改进版的插入排序 N的若干倍 * 递增序列长度，空间复杂度：1

### 堆排序

思想：对简单选择排序进行的一种改进。将待排序的序列构造成一个大顶堆。把最大元素和当前堆中数组的最后一个元素交换位置，并且不删除它，就可得到一个从尾到头的递减序列，从正向来看就是一个递增序列。

```java
public class heap {
    public static void buildHeap(int[] num, int parent, int length) {
        for(int child = 2 * parent + 1; child < length; child = 2 * child + 1) {
            if(child + 1 < length && num[child] < num[child + 1]) {
                child++;
            }
            if(num[parent] < num[child]) {//若子节点值更大，则与父结点进行交换
                swap(num, parent, child);
                parent = child;
            } else {
                break;
            }
        }
    }
    public static void swap(int[] num, int i, int j) {
        int temp = num[i];
        num[i] = num[j];
        num[j] = temp;
    }
    public static void sort(int[] num) {
        for(int parent = num.length / 2 - 1; parent >= 0; parent--) {//从右向左，从下向上，建最大堆
            buildHeap(num, parent, num.length);
        }
        for(int i = num.length - 1; i > 0; i--) {
            swap(num, 0, i);
            buildHeap(num, 0, i);
        }
    }
}
```

稳定性：不稳定，时间复杂度：O（NlogN），空间复杂度：1

### 归并排序

思想：将数组分成两部分，分别进行排序，然后归并起来。 

```java
public static void sort(int[] num, int low, int high) {
    int mid = low + (high - low) / 2;
    if(low < high) {
        sort(num, low, mid);
        sort(num, mid + 1, high);
        merge(num, low, mid, high);
    }
}
public static void merge(int[] num, int low, int mid, int high) {
    int[] temp = new int[high - low + 1];
    int i = low;//左指针
    int j = mid + 1;//右指针
    int k = 0;
    while(i <= mid && j <= high) {//将较小的数先移入新数组中
        if(num[i] <= num[j]) {
            temp[k++] = num[i++];
        } else {
            temp[k++] = num[j++];
        }
    }
    //把左边剩余的数移入数组
    while(i <= mid) {
        temp[k++] = num[i++];
    }
    //把右边剩余的数移入数组
    while(j <= high) {
        temp[k++] = num[j++];
    }
    //将新数组中的值拷入原数组
    k = 0;
    while(low <= high) {
        num[low++] = temp[k++];
    }
}
```

稳定性：稳定，时间复杂度：O（NlogN），空间复杂度：N

### 快速排序

思想：通过一个切分元素将数组分为两个子数组。左子数组小于等于切分元素，右子数组大于等于切分元素，将这两个子数组排序也就将整个数组排序了。 

```java
public class quick {
    public static void sort(int[] num, int left, int right) {
        if(left > right) {
            return;
        } else {
            int base  = divide(num, left, right);
            sort(num, left, base - 1);
            sort(num, base + 1, right);
        }
    }
    public static int divide(int[] num, int left, int right) {
        int base = num[left];
        while(left < right) {
            //从数组右端开始，向左遍历，直到找到小于base的数
            while(left < right && num[right] > base) {
                right--;
            }
            //找到了比base小的元素，将这个元素放到最左边的位置
            num[left] = num[right];
            //从数组左端开始，向右遍历，直到找到大于base的数
            while(left < right && num[left] < base) {
                left++;
            }
            //找到了比base大的元素，将这个元素放到最右边的位置
            num[right] = num[left];
        }
        //最后将base放到left位置，此时，left左边的值都比它小，右边的值都比它大
        num[left] = base;
        return left;
    }
}
```

稳定性：不稳定，时间复杂度：O（NlogN），空间复杂度：logN



## 算法思想

### 双指针

双指针主要**用于遍历数组，两个指针指向不同的元素，从而协同完成任务**。 

1、有序数组的 Two Sum：在有序数组中找出两个数，使它们的和为 target。 

```java
public static int[] twoSum(int[] numbers, int target) {
    int[] res = new int[2];
    if(numbers == null || numbers.length == 0) {
        return res;
    }
    int left = 0, right = numbers.length - 1;
    while(left < right) {
        int sum = numbers[left] + numbers[right];
        if(sum < target) {
            left++;
        } else if(sum > target) {
            right--;
        } else {
            res[0] = left + 1;
            res[1] = right + 1;
            break;
        }
    }
    return res;
}
```

2、反转字符串中的元音字符。 

```java
public String reverseVowels(String s) {
    Set<Character> set = new HashSet<>(Arrays.asList('a', 'e', 'i', 'o', 'u',
                                                     'A', 'E', 'I', 'O', 'U'));
    int left = 0, right = s.length() - 1;
    char[] res = new char[s.length()];
    while(left <= right) {
        char c1 = s.charAt(left);
        char c2 = s.charAt(right);
        if(!set.contains(c1)) {
            res[left++] = c1;
        } else if(!set.contains(c2)) {
            res[right--] = c2;
        } else {
            res[left++] = c2;
            res[right--] = c1;
        }
    }
    return new String(res);
}
```

3、判断链表是否存在环。

```java
public boolean hasCycle(ListNode head) {
    if(head == null) {
        return false;
    }
    ListNode first = head;
    ListNode second = head.next;
    while(second != null && second.next != null) {
        if(first == second) {
            return true;
        }
        first = first.next;
        second = second.next.next;
    }
    return false;
}
```

### 排序

前K个高频元素：给定一个非空的整数数组，返回其中出现频率前 k 高的元素。 

### 贪心思想

保证**每次操作都是局部最优的，并且最后得到的结果是全局最优**的。 

1、分配饼干：每个孩子都有一个满足度，每个饼干都有一个大小，只有饼干的大小大于等于一个孩子的满足度，该孩子才会获得满足。求解最多可以获得满足的孩子数量。 

给一个孩子的饼干应当尽量小又能满足该孩子，这样大饼干就能拿来给满足度比较大的孩子。因为最小的孩子最容易得到满足，所以先满足最小的孩子。 

```java
public int findContentChildren(int[] g, int[] s) {
    Arrays.sort(g);
    Arrays.sort(s);
    //g:胃口 s:尺寸
    int gi = 0, si = 0;
    while(gi < g.length && si < s.length) {
        if(s[si] >= g[gi]) {
            gi++;
        }
        si++;
    }
    return gi;
}
```

2、判断是否为子序列。 

```java
public boolean isSubsequence(String s, String t) {
    char[] chars = s.toCharArray();
    int index = -1;
    for(int i = 0; i < s.length(); i++) {
        index = t.indexOf(chars[i], index + 1);
        if(index < 0) {
            return false;
        }
    }
    return true;
}
```

3、子数组最大的和。 

```java
public int maxSubArray(int[] nums) {
    if(nums == null || nums.length == 0) {
        return 0;
    }
    int preSum = nums[0];
    int maxSum = preSum;
    for(int i = 1; i < nums.length; i++) {
        if(preSum < 0) {
            preSum = nums[i];
        } else {
            preSum = preSum + nums[i];
        }
        maxSum = Math.max(maxSum, preSum);
    }
    return maxSum;
}
```

### 二分查找

1、有序数组的 Single Element：一个有序数组只有一个数不出现两次，找出这个数。 

```java
public int singleNonDuplicate(int[] nums) {
    if(nums == null || nums.length == 0) {
        return -1;
    }
    int low = 0, high = nums.length - 1;
    while(low < high) {
        int mid = low + (high - low) / 2;
        if(mid % 2 == 1) {//保证low、high、mid都在偶数位，使得查找区间大小一直都是奇数
            mid--;
        } 
        if(nums[mid] == nums[mid + 1]) {
            low = mid + 2;
        } else {
            high = mid;
        }
    }
    return nums[low];
 }
```

2、旋转数组的最小数字：假设按照升序排序的数组在预先未知的某个点上进行了旋转。 

```java
public int findMin(int[] nums) {
    if(nums == null || nums.length == 0) {
        return -1;
    }
    int low = 0, high = nums.length - 1;
    while(low < high) {
        int mid = low + (high - low) / 2;
        if(nums[mid] <= nums[high]) {
            high = mid;
        } else {
            low = mid + 1;
        }
    }
    return nums[low];
}
```

### 搜索

深度优先搜索和广度优先搜索广泛运用于树和图中，但是它们的应用远远不止如此。

1、BFS：广度优先搜索一层一层地进行遍历，每层遍历都以上一层遍历的结果作为起点，遍历一个距离能访问到的所有节点。需要注意的是，遍历过的节点不能再次被遍历。（队列）

2、DFS：深度优先搜索在得到一个新节点时立即对新节点进行遍历。（栈）

3、Backtracking（回溯）：属于 DFS。

- 普通 DFS 主要用在**可达性问题** ，这种问题只需要执行到特定的位置然后返回即可。
- Backtracking 主要用于求解 **排列组合** 问题，例如有 { ‘a’,’b’,’c’ } 三个字符，求解所有由这三个字符排列得到的字符串，这种问题在执行到特定的位置返回之后还会继续执行求解过程。

因为 Backtracking 不是立即返回，而要继续求解，因此在程序实现时，需要注意对元素的标记问题： 

- 在**访问一个新元素进入新的递归调用**时，需要**将新元素标记为已经访问**，这样才能在继续递归调用时不用重复访问该元素；
- 但是**在递归返回时，需要将元素标记为未访问，因为只需要保证在一个递归链中不同时访问一个元素**，可以访问已经访问过但是不在当前递归链中的元素。

例：给定一个没有重复数字的序列，返回其所有可能的全排列。 

```java
public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        List<Integer> list = new ArrayList<>();
        boolean[] isvisted = new boolean[nums.length];
        backtracing(res, list, isvisted, nums);
        return res;
    }
    public void backtracing(List<List<Integer>> res, List<Integer> list,
                            boolean[] isvisited, int[] nums) {
        if(list.size() == nums.length) {
            res.add(new ArrayList<>(list));
        }
        for(int i = 0; i < nums.length; i++) {
            if(isvisited[i]) {
                continue;
            }
            list.add(nums[i]);
            isvisited[i] = true;
            backtracing(res, list, isvisited, nums);
            list.remove(list.size() - 1);
            isvisited[i] = false;
        }
 }
```

### 动态规划

递归和动态规划都是**将原问题拆分成多个子问题然后求解**，他们之间最本质的区别是，**动态规划保存了子问题的解，避免重复计算**。 

1、数组区间和：给定一个整数数组 nums，求出数组从索引 i 到 j (i ≤ j) 范围内元素的总和，包含 i, j 两点。 

```java
int[] sums; 
public NumArray(int[] nums) {
    //求区间i~j的值，相当于sums[j + 1] - sums[i],其中sums[i]为0~i-1的和
    sums = new int[nums.length + 1];
    for(int i = 1; i < nums.length + 1; i++) {
        sums[i] = sums[i - 1] + nums[i - 1];
    }
}
public int sumRange(int i, int j) {
    return sums[j + 1] - sums[i];
}
```

2、最长递增子序列：给定一个无序的整数数组，找到其中最长上升子序列的长度。 

```java
public int lengthOfLIS(int[] nums) {
    if(nums == null || nums.length == 0) {
        return 0;
    }
    int[] dp = new int[nums.length];
    for(int i = 0; i < nums.length; i++) {
        int max = 1;
        for(int j = 0; j < i; j++) {
            if(nums[i] > nums[j]) {
                max = Math.max(max, dp[j] + 1);
            }
        }
        dp[i] = max;
    }
    Arrays.sort(dp);
    return dp[dp.length - 1];
}
```

3、最长公共子序列：对于两个子序列 S1 和 S2，找出它们最长的公共子序列。 

![](img\01.PNG)

```java
public static int lengthOfLCS(int[] nums1, int[] nums2) {
    int n1 = nums1.length, n2 = nums2.length;
    int[][] dp = new int[n1 + 1][n2 + 1];
    for(int i = 1; i < n1 + 1; i++) {
        for(int j = 1; j < n2 + 1; j++) {
            if(nums1[i - 1] == nums2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[n1][n2];
}
```

4、0-1 背包：有一个容量为 N 的背包，要用这个背包装下物品的价值最大，这些物品有两个属性：体积 w 和价值 v。 

![](img\02.PNG)

```java
public static int knapsack(int W, int N, int[] weights, int[] values) {
    int[][] dp = new int[N + 1][W + 1];
    for(int i = 1; i < N + 1; i++) {
        int w = weights[i - 1], v = values[i - 1];
        for(int j = 1; j < W + 1; j++) {
            if(j >= w) {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - w] + v);
            } else {
                dp[i][j] = dp[i - 1][j];
            }
        }
    }
    return dp[N][W];
}
```



## 数据结构

### About

线性结构：数组、栈、队列、链表、哈希表...

树结构：二叉树、二分搜索树、AVL、红黑树、Treap、Splay、堆、Trie、线段树、K-D树、并查集、哈夫曼树...

图结构：邻接矩阵、邻接表...

应用：

- 数据库：树结构（AVL、红黑树、Treap、伸展树、B树）、哈希表；
- 操作系统：多任务间切换（系统栈，优先队列：堆）；
- 文件压缩：哈夫曼树；
- 通讯录：Trie-前缀树；
- 大量的算法，以数据结构为基石：寻路算法（图论算法--->DFS：使用栈，BFS：使用队列）；

### 数组

1、把数据码成一排进行存放；

2、索引可以有语意，也可以没有语意；

3、最大优点：**快速查询，最好应用于“索引有语意”的情况**，并非所有有语意的索引都适用于数组；

4、size：**数组中第一个没有元素的位置**；

5、向数组末尾添加元素相当于在size位置处添加元素（将size索引位置值变为添加的值，size++）；

6、向数组指定位置添加元素（先将size-1处的元素值依次往后移，再将元素插入指定位置，size++）；

7、删除指定位置元素（将要删除索引处后面元素相继向左移动，size--）；

8、泛型：让数据结构可以放置“任何”数据类型（不可以是基本数据类型-8种，只能是类对象）；

9、**动态数组（扩容、缩容）**：新数组开辟新空间（可以装更多元素），将原来数组元素赋值到新数组；

10、时间复杂度分析：O（1），O（n），O（logn），O（nlogn），O（n^2）

大O描述的是**算法运行时间和输入数据之间的关系**；

11、动态数组的时间复杂度：

- 添加操作：addLast（e）-> O（1）、addFIrst（e）-> O（n）、add（index, e）->	O（n / 2） = O（n）、resize（）-> O（n）；
- 删除操作：removeLast（e）-> O（1）、removeFIrst（e）-> O（n）、remove（index, e）-> O（n / 2） = O（n）、resize（）-> O（n）；
- 修改操作：set（index, e）-> O（1）；
- 查找操作：get（index）-> O（1）、contains（e）-> O（n）、find（e）-> O（n）；

总结：

动态数组时间复杂度：

- 增：O（n）
- 删：O（n）
- 改：已知索引O（1）；未知索引O（n）
- 查：已知索引O（1）；未知索引O（n）

12、均摊复杂度：耗时的操作不会每次都触发，耗时的操作可分摊到其他操作中；

13、防止复杂度震荡：Lazy，当size == capacity / 4时，才将capacity减半；

### 栈和队列

1、栈（Stack）：

- 是一种线性结构
- 相比数组，栈对应的操作是数组的子集
- 只能从一端添加元素，也只能从同一端取出元素（栈顶）
- 是一种后进先出的数据结构（LIFO，Last In First Out）
- 栈拥有不可思议的作用

2、栈的应用：

- 无处不在的undo操作（撤销）-编辑器
- 程序调用的系统栈-操作系统

![](img\stack01.PNG)

- 括号匹配-编译器

3、栈的实现-Stack<E>：

- void push<E> 入栈 O(1) 均摊
- E pop() 出栈 O(1) 均摊
- E peek() 查看栈顶元素（top） O(1)
- int getSize() 栈大小 O(1)
- boolean isEmpty() 栈是否为空 O(1)

4、队列（Queue）：

- 是一种线性结构
- 相比数组，队列对应的操作是数组的子集
- 只能从一端（队尾）添加元素，只能从另一端（队首）取出元素
- 队列是一种先进先出的数据结构（先到先得）
- FIFO，First In First Out

5、队列的实现-Queue<E>：

- void enqueue(E) O(1) 均摊
- E dequeue() O(n)
- E getFront() O(1)
- int getSize() O(1)
- boolean isEmpty() O(1)

6、循环队列：

- front == tail 队列为空，（tail + 1） %  c == front 队列为满
- 入队：只需维护tail（tail++ % 数组长度）
- 出队：只需维护front（++）

7、循环队列的实现-LoopQueue<E>：

- void enqueue(E) O(1) 均摊
- E dequeue() O(1) 均摊
- E getFront() O(1)
- int getSize() O(1)
- boolean isEmpty() O(1)

### 链表

1、线性数据结构：底层依托静态数组，靠resize解决固定容量问题

- 动态数组
- 栈
- 队列

2、链表：真正的动态数据结构

- 最简单的动态数据结构
- 更深入的理解引用（或者指针）
- 更深入的理解递归
- 辅助组成其他数据结构

3、链表Linked List：

- 数据存储在“节点”（Node）中；

  class Node {

  ​	E e；

  ​	Node next;

  }

- 优点：真正的动态，不需要处理固定容量的问题

- 缺点：丧失了随机访问的能力

4、数组和链表的对比：

- 数组最好用于索引有语意的情况
- 最大的优点：支持快速查询
- 链表不适合用于索引有语意的情况
- 最大的优点：动态

5、在链表头添加元素：

![](img\linkedlist01.PNG)

6、在链表中间添加元素：

![](img\linkedlist02.PNG)

关键：找到要添加的节点的前一个节点；

7、链表元素的删除：

![](img\linkedlist03.PNG)

8、复杂度分析：

- 添加操作：addLast(e) O(n)、addFirst(e) O(1)、add(index, e) O(n / 2) = O(n)
- 删除操作：removeLast(e) O(n)、removeFirst(e) O(1)、remove(index, e) O(n / 2) = O(n)
- 修改操作：set(index, e) O(n)
- 查找操作：get(index) O(n)、contains(e) O(n)

9、对链表头进行操作（增、删）：O（1）、只查链表头的元素：O（1）

10、链表实现栈、链表实现队列

![](img\linkedlist04.PNG)

### 链表和递归

1、递归：本质上，将原来的问题，转化为更小的同一问题

2、求解最基本问题，把原问题转化为更小的问题

![](img\linkedlist05.PNG)

3、递归函数：

- 递归函数的调用，本质就是函数调用
- 只不过调用的函数是自己而已

![](img\Linkedlist06.PNG)

递归调用是有代价的：函数调用+系统栈空间

4、双链表：

![](img\linklist2.PNG)

class  Node {

​	E e;

​	Node next, prev;

}

加入虚拟头节点：对于很多操作，在链表头不需特殊讨论

5、循环链表：

![](img\xunhuan.PNG)

6、数组链表：

![](img\array.PNG)

### 二分搜索树

1、树结构本身是一种天然的组织结构；

2、树结构：高效

3、二分搜索树（Binary Search Tree）局限性

​      平衡二叉树：AVL；红黑树

​      堆；并查集

​      线段树；Trie（字典树，前缀树）

4、二叉树：

- 和链表一样，动态数据结构

  class Node {

  ​	E e;

  ​	Node left; 左孩子

  ​	Node right; 右孩子

  }

- 二叉树具有唯一根节点

- 二叉树每个节点最多有两个孩子

- 二叉树每个节点最多有一个父亲节点

- 二叉树具有天然递归结构

  每个节点的左子树也是二叉树

  每个节点的右子树也是二叉树，一个节点也是二叉树，空也是二叉树

二分搜索树：

- 二分搜索树是二叉树

- 二分搜索树的每个节点的值：

  大于其左子树的所有节点的值

  小于其右子树的所有节点的值

- 每一棵子树也是二分搜索树

- 存储的元素必须有可比较性（存储数据的局限性）

- 二分搜索树不包含重复元素：

  如果想包含重复元素的话，改变定义：左子树小于等于节点，或者右子树大于等于节点

  注意：数组和链表，可以有重复元素

- 二分搜索树添加元素的非递归写法，和链表很像

- 在二分搜索树方面，递归比非递归实现简单

6、遍历：

- 把所有节点都访问一遍
- 访问的原因和业务相关
- 在线性结构下，遍历是及其容易的
- 在树结构下，也没那么难
- 对遍历操作，两颗子树都要顾及

7、后序遍历应用：为二分搜索树释放内存

8、栈消除递归

9、深度优先遍历：前序、中序、后序；广度优先遍历（搜索策略）：层序遍历（**非递归实现-借助队列**）

**广度优先遍历：更快的找到问题的解，常用于算法设计中-最短路径**

10、二分搜索树删除节点：

![](img\bst01.PNG)

找后继和前驱都可以删除；

### 集合和映射

1、集合：每个元素只能存在一次（去重）

Set<E>:

- void add(E) 不能添加重复元素
- void remove(E) 
- boolean contains(E)
- int getSize()
- boolean isEmpty()

应用：客户统计、词汇量统计

2、BST和LinkedList都属于动态数据结构，可以用来实现set

![](img\set01.PNG)

3、集合类的复杂度分析：

LinkedListSet:

- 增add：O(n)
- 查contains：O(n)
- 删remove：O(n)

BSTSet:

- 增add：O(h) h为二分搜索树的高度 h=logn
- 查contains：O(h)
- 删remove：O(h)

4、java集合底层是：红黑树，本质是有序的集合

基于链表实现的集合：无序

5、![](img\set02.PNG)

6、映射Map：

- 存储（键，值）数据对的数据结构（Key，Value）
- 根据键（Key），寻找值（Value）
- 非常容易使用链表或者二分搜索树实现

![](img\map01.PNG)

![](img\map02.PNG)

7、映射的时间复杂度分析：

![](img\map03.PNG)

8、有序映射和无序映射：

- 有序映射中的键具有顺序性（基于搜索树的实现）
- 无序映射中的键没有顺序性（基于哈希表的实现）

### 优先队列和堆

1、普通队列：先进先出，后进后出

​      优先队列：出队顺序和入队顺序无关，和优先级相关；（应用：任务调度）

2、优先队列实现：

- 普通线性结构：入队-O（1）、出队-O（n）
- 顺序线性结构：入队-O（n）、出队-O（1）
- 堆：入队-O（logn）、出队-O（logn）

3、堆的基本结构：

- 二叉堆是一颗**完全二叉树**（完全二叉树：把元素顺序排列成树的形状）
- **堆中某个节点的值总是不大于其父节点的值**--最大堆

4、数组存储二叉堆：

索引从1开始：

- parent（i）= i / 2
- left child (i) = 2 * i
- right child(i) = 2 * i + 1

索引从0开始：

- parent（i ）=（ i - 1） / 2
- left child (i ) = 2 * i + 1
- right child(i) = 2 * i + 2

5、堆的时间复杂度分析：

- add O（logn）
- extractMax （logn）

6、replace操作：

- replace：取出最大元素后，放入一个新元素
- 实现1：可以先extractMax，再add，两次O（logn）的操作
- 实现2：可以直接将堆顶元素替换以后Sift Down，一次O（logn）的操作

7、heapify操作：将任意数组整理成堆的形状

- 将n个元素逐个插入到一个空堆中，算法复杂度是O（nlogn）
- heapify的过程，算法复杂度为O（n）

8、优先队列的经典问题：在1000000个元素中选出前100名；

- 在N个元素中选出前M个元素
- 排序？ NlogN
- 使用优先队列？NlogM

使用优先队列，维护当前看到的前M个元素；需要使用最小堆；

### 线段树（区间树）

1、关心的是一个线段或区间

2、最经典的线段树问题：区间染色、区间查询

3、![](img\st01.PNG)

![](img\st02.PNG)

4、线段树不一定是完全二叉树，**线段树是平衡二叉树，堆也是平衡二叉树**

平衡二叉树：树的最大深度与最小深度相差最多为1

5、![](img\st03.PNG)

6、区间操作的数据结构：

- 线段树
- 树状数组（Binary Index Tree）

区间相关的问题：RMQ（Range Minimum Query）

### Trie字典树 前缀树

1、Trie：专门为字符串设计

2、字典：如果有n个条目，使用树结构，查询的时间复杂度是O（logn），如果有100万个条目（2^20），logn大约为20；

​     Trie：查询每个条目的时间复杂度，和字典中一共有多少条目无关，时间复杂度为O（w），w为查询单词的长度，大多数单词的长度小于10；

![](img\trie01.PNG)

3、Trie：每个节点有若干指向下个节点的指针：

class Node {

​	boolean isWord;//是否访问到单词的结尾

​	Map<char, Node> next;

}

4、Trie的局限性：最大的问题（**空间**！）

解决办法：

- 压缩字典树（Compressed Trie）
- 三分搜索树（Ternary Search Trie）

5、字符串模式识别：后缀树

6、更多字符串问题：

- 子串查询（KMP、Boyer-Moore、Rabin-Karp）
- 文件压缩（哈夫曼）
- 模式匹配
- 编译原理
- DNA

### 并查集（Union Find）

1、一种很不一样的树形结构，孩子指向父亲，可以回答**连接问题**

2、并查集（**连接问题和路径问题**）：

- 网络中节点间的连接状态：网络是个抽象的概念-用户之间形成的网络
- 数学中的集合类实现

回答连接问题比路径问题要回答的问题少

3、对于一组数据，主要支持两个动作：

- union（p，q）
- isConnected（p， q）

4、并查集实现：

- Quick Find：unionElements(p, q)-O(n)、isConnected(p, q)- O(1)

5、并查集时间复杂度：O（log*n） 近乎是O（1）级别的

### 平衡二叉树与AVL树

1、**AVL树是最经典的平衡二叉树**，AVL发明人：G. M.  Adelson-Velsky 和 E. M. Landis

2、AVL树是最早的自平衡的二分搜索树结构

3、平衡二叉树：

- 满二叉树一定是平衡二叉树
- 完全二叉树、线段树也是平衡二叉树
- AVL树中，对于任意一个节点，**左子树和右子树的高度差不能超过1**，平衡二叉树的高度和节点数量之间的关系是O（logn）的
- 标注节点的高度，计算平衡因子：左右子树高度差

4、右旋转：插入的元素在不平衡的节点的左侧的左侧；

​      左旋转：插入的元素在不平衡的节点的右侧的右侧；

### 红黑树

1、红黑树（是一棵二分搜索树）：

- 每个节点或者是红色的，或者是黑色的
- 根节点是黑色的
- 每一叶子节点（最后的空节点）是黑色的
- 如果一个节点是红色的，那么它的孩子节点都是黑色的
- **从任意一个节点到叶子节点，经过的黑色节点是一样的**

2、2-3树：

- 满足二分搜索树的基本性质

- 节点可以存放一个元素或者两个元素

- 每个节点有2个或者3个孩子（2-3树）

- 2-3树是一棵绝对平衡的树(从根节点到任意一个叶子节点所经过的节点数量相同)

  ![](img\2-3树.PNG)

3、红黑树：

- 红色：节点与父亲节点融合在一起
- 红黑树是保持”黑平衡“的二叉树，严格意义上，不是平衡二叉树，最大高度2logn ->O（logn）

4、红黑树添加新元素：

![](img\rb01.PNG)

维护的时机：和AVL树一样，添加节点后回溯向上维护

5、红黑树的性能总结：

- 对于完全随机的数据，普通的二分搜索树很好用！
- 缺点：极端情况退化成链表（或者高度不平衡）
- 对于查询较多的使用情况，AVL树很好用！
- 红黑树牺牲了平衡性（2logn的高度）
- **统计性能更优**（综合增删改查所有的操作）

6、红黑树更多问题：红黑树中删除节点、左倾红黑树、右倾红黑树、另一种统计性能优秀的树结构：Splay Tree（伸展树）-->局部性原理：刚被访问的内容下次高概率被再次访问、基于红黑树的Map和Set（java.util中的TreeMap和TreeSet基于红黑树）

### 哈希表

1、哈希表：每一个字符都和一个索引相对应 	O(1)的查找操作！

2、哈希函数：对于给定字符，将其转为索引的方法

3、哈希冲突：每一个”键“通过哈希函数的转换对应相同的”索引“

4、哈希表充分体现了算法设计领域的经典思想：**空间换时间**，哈希表是时间和空间之间的平衡

5、哈希函数的设计：”键“通过哈希函数得到的”索引“**分布越均匀越好**

6、大整数：

- 通常做法：取模（陷阱->分布不均匀）
- 简单解决办法：模一个素数

7、浮点型（**转成整型处理**）：在计算机中都是32位或者64位的二进制表示，只不过计算机解析成了浮点数

8、字符串：转成整型处理

![](img\hash01.PNG)

![](img\hash02.PNG)

9、复合类型：转成整型处理

![](img\hash03.PNG)

10、哈希函数设计原则：

- 一致性：如果a==b，则hash（a）= hash（b）
- 高效性：计算高效简便
- 均匀性：哈希值均匀分布

11、Java默认的hash函数是根据对象的地址计算hashcode

12、哈希冲突处理：

- 链地址法（Separate Chaining）

13、Java8之前，每个位置对应一个链表；

Java8开始，当哈希冲突达到一定程度，每一个位置从链表转成红黑树；

14、哈希表，链地址法时间复杂度：

总共有M个地址，如果放入哈希表的元素为N，

- 如果每个地址是链表：O(N/M)
- 如果每个地址是平衡树：O(log(N/M))

15、哈希表：

- 均摊复杂度为O（1）
- 牺牲了顺序性

16、集合、映射：

- 有序集合、有序映射（平衡树）
- 无序集合、无序映射（哈希表）

17、哈希冲突的处理方法：

- **开放地址法**：开放（每个地址对任何元素开放）

  **线性探测**（遇到哈希冲突+1）、**平方探测**（遇到冲突 + 1+ 4 + 9 + 16）、**二次哈希**（遇到哈希冲突 + hash2（key））

  负载率：哈希表存储的元素分比

- **链地址法**：封闭

- **再哈希法**：用另外哈希函数找索引

- Coalesced Hashing：综合了Separate Chaining 和 Open Addressing

### 总结

- 线性结构：动态数组、普通队列、栈、链表、哈希表
- 树形结构：二分搜索树、AVL树、红黑树（统计性能更高）、 堆、线段树、Trie、并查集
- 图结构：邻接表、邻接矩阵

抽象数据结构：

- 线性表：动态数组、链表
- 栈、队列
- 集合（有序、无序）、映射（有序、无序）

![](img\end.PNG)



## 数据结构底层

1、数组：

```java
public class Array<E> {

    private E[] data;
    private int size;

    public Array(int capacity) {//构造函数，传入数组的容量capacity构造Array
        data = (E[])new Object[capacity];
        size = 0;
    }

    public Array() {//无参数的构造函数，默认数组的容量capacity=10
        this(10);
    }

    public int getSize() {//获取数组中的元素个数
        return size;
    }

    public int getCapacity() {//获取数组的容量
        return data.length;
    }

    public boolean isEmpty() {//返回数组是否为空
        return size == 0;
    }

    public void addLast(E e) {//向所有元素后添加一个新元素e
        add(size, e);
    }

    public void addFirst(E e) {//向所有元素头添加一个新元素e
        add(0, e);
    }

    public void add(int index, E e) {//在第index位置处插入一个新元素e
        if(index < 0 || index > size) {
            throw new IllegalArgumentException("AddLast failed. Require index >= 0 and index <= size");
        }
        if(size == data.length) {
            resize(2 * data.length);
        }
        for(int i = size -1; i >= index; i--) {
            data[i + 1] = data[i];
        }
        data[index] = e;
        size++;
    }

    @Override
    public String toString() {
        StringBuilder res = new StringBuilder();
        res.append(String.format("Array: size = %d, capacity = %d\n", size, data.length));
        res.append('[');
        for(int i = 0; i < size; i++) {
            res.append(data[i]);
            if(i != size - 1) {
                res.append(", ");
            }
        }
        res.append(']');
        return res.toString();
    }

    public E get(int index) {//获取index索引位置的元素
        if(index < 0 || index >= size) {
            throw new IllegalArgumentException("Get failed. Index is illegal.");
        }
        return data[index];
    }

    void set(int index, E e) {//修改index索引位置的元素
        if(index < 0 || index >= size) {
            throw new IllegalArgumentException("Set failed. Index is illegal.");
        }
        data[index] = e;
    }

    public boolean contains(E e) {//查找数组中是否有元素e
        for(int i = 0; i < size; i++) {
            if(data[i] == e) {
                return true;
            }
        }
        return false;
    }

    public int find(E e) {//查找数组中元素e所在的索引，如果不存在元素e，返回-1
        for(int i = 0; i < size; i++) {
            if(data[i].equals(e)) {
                return i;
            }
        }
        return -1;
    }

    public E remove(int index) {//从数组中删除index位置的元素，返回删除的元素
        if(index < 0 || index >= size) {
            throw new IllegalArgumentException("Remove failed. Index is illegal.");
        }
        E ret = data[index];
        for(int i = index + 1; i < size; i++) {
            data[i - 1] = data[i];
        }
        size--;
        data[size] = null;//loitering objects != memory leak
        if(size == data.length / 4 && data.length / 2 != 0) {
            resize(data.length / 2);
        }
        return ret;
    }

    public E removeFirst() {
        return remove(0);
    }

    public E removeLast() {
        return remove(size - 1);
    }

    public void removeElement(E e) {//从数组中删除元素e
        int index = find(e);
        if(index != -1) {
            remove(index);
        }
    }

    private void resize(int newCapacity) {//动态数组
        E[] newData = (E[])new Object[newCapacity];
        for(int i = 0; i < size; i++) {
            newData[i] = data[i];
        }
        data = newData;
    }
}
```

2、Stack：

```java
public class LinkedListStack<E> implements Stack<E> {
    private LinkedList<E> list;

    public LinkedListStack() {
        list = new LinkedList<>();
    }

    @Override
    public int getSize() {
        return list.getSize();
    }

    @Override
    public boolean isEmpty() {
        return list.isEmpty();
    }

    @Override
    public void push(E e) {
        list.addFirst(e);
    }

    @Override
    public E pop() {
        return list.removeFirst();
    }

    @Override
    public E peek() {
        return list.getFirst();
    }

    @Override
    public String toString() {
        StringBuilder res = new StringBuilder();
        res.append("Stack: top ");
        res.append(list);
        return res.toString();
    }
}
```

3、Queue：

```java
public class LinkedListQueue<E> implements Queue<E> {
    private class Node {
        public E e;
        public Node next;

        public Node(E e, Node next) {
            this.e = e;
            this.next = next;
        }

        public Node(E e) {
            this(e, null);
        }

        public Node() {
            this(null, null);
        }

        @Override
        public String toString() {
            return e.toString();
        }
    }

    private Node head, tail;
    private int size;

    public LinkedListQueue() {
        head = null;
        tail = null;
        size = 0;
    }

    @Override
    public int getSize() {
        return size;
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    @Override
    public void enqueue(E e) {//链表尾插入
        if(tail == null) {
            tail = new Node(e);
            head = tail;
        } else {
            tail.next = new Node(e);
            tail = tail.next;
        }
        size++;
    }

    @Override
    public E dequeue() {//链表头删除
        if(isEmpty()) {
           throw new IllegalArgumentException("Cannot dequeue from an empty queue.");
        }
        Node retNode = head;
        head = head.next;
        retNode.next = null;
        if(head == null) {
            tail = null;
        }
        size--;
        return retNode.e;
    }

    @Override
    public E getFront() {
        if(isEmpty()) {
            throw new IllegalArgumentException("Queue is empty.");
        }
        return head.e;
    }

    @Override
    public String toString() {
        StringBuilder res = new StringBuilder();
        res.append("Queue: front ");
        Node cur = head;
        while (cur != null) {
            res.append(cur + "->");
            cur = cur.next;
        }
        res.append("Null tail");
        return res.toString();
    } 
}
```

4、LoopQueue：

```java
public class LoopQueue<E> implements Queue<E> {
    private E[] data;
    private int front, tail;
    private int size;

    public LoopQueue(int capapcity) {
        data = (E[]) new Object[capapcity + 1];
        front = 0;
        tail = 0;
        size = 0;
    }
    public LoopQueue() {
        this(10);
    }

    public int getCapacity() {
        return data.length - 1;
    }

    @Override
    public int getSize() {
        return size;
    }

    @Override
    public boolean isEmpty() {
        return front == tail;
    }

    @Override
    public void enqueue(E e) {
        if((tail + 1) % data.length == front) {
            resize(getCapacity() * 2);
        }
        data[tail] = e;
        tail = (tail + 1) % data.length;
        size++;
    }

    private void resize(int newCapacity) {
        E[] newData = (E[]) new Object[newCapacity + 1];
        for(int i = 0; i < size; i++) {
            newData[i] = data[(i + front) % data.length];
        }
        data = newData;
        front = 0;
        tail = size;
    }

    @Override
    public E dequeue() {
        if(isEmpty()) {
            throw new IllegalArgumentException("cannot dequeue from an empty queue.");
        }
        E res = data[front];
        data[front] = null;
        front = (front + 1) % data.length;
        size--;
        if(size == getCapacity() / 4 && getCapacity() / 2 != 0) {
            resize(getCapacity() / 2);
        }
        return res;
    }

    @Override
    public E getFront() {
        if(isEmpty()) {
            throw new IllegalArgumentException("Queue is empty.");
        }
        return data[front];
    }

    @Override
    public String toString() {
        StringBuilder res = new StringBuilder();
        res.append(String.format("Queue: size = %d, capacity = %d\n", size, getCapacity()));
        res.append("front [");
        for(int i = front; i != tail; i = (i + 1) % data.length) {
            res.append(data[i]);
            if((i + 1) % data.length != tail) {
                res.append(", ");
            }
        }
        res.append("] tail");
        return res.toString();
    }
}
```

5、AVL树（平衡树）：

```java
public class AVLTree<K extends Comparable<K>, V> implements Map<K, V> {
    private class Node {
        public K key;
        public V value;
        public Node left, right;
        public int height;

        public Node(K key, V value) {
            this.key = key;
            this.value = value;
            left = null;
            right = null;
            height = 1;
        }
    }

    private Node root;
    private int size;

    public AVLTree() {
        this.root = null;
        this.size = 0;
    }

    @Override
    public int getSize() {
        return size;
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    //获得节点node的高度
    public int getHeight(Node node) {
        if(node == null) {
            return 0;
        }
        return node.height;
    }

    //获得节点node的平衡因子
    private int getBalanceFactor(Node node) {
        if(node == null) {
            return 0;
        }
        return getHeight(node.left) - getHeight(node.right);
    }

    //判断该二叉树是否是一棵二分搜索树
    public boolean isBST() {
        ArrayList<K> keys = new ArrayList<>();
        inOrder(root, keys);
        for(int i = 1; i < keys.size(); i++) {
            if(keys.get(i - 1).compareTo(keys.get(i)) > 0) {
                return false;
            }
        }
        return true;
    }
    private void inOrder(Node node, ArrayList<K> keys) {
        if(node == null) {
            return;
        }
        inOrder(node.left, keys);
        keys.add(node.key);
        inOrder(node.right, keys);
    }

    //判断该二叉树是否是一棵平衡二叉树
    public boolean isBanlanced() {
        return isBanlanced(root);
    }
    //判断以Node为根的二叉树是否是一棵平衡二叉树，递归算法
    private boolean isBanlanced(Node node) {
        if(node == null) {
            return true;
        }
        int balanceFactor = getBalanceFactor(node);
        if(Math.abs(balanceFactor) > 1) {
            return false;
        }
        return isBanlanced(node.left) && isBanlanced(node.right);
    }

    // 对节点y进行向右旋转操作，返回旋转后新的根节点x
    //        y                              x
    //       / \                           /   \
    //      x   T4     向右旋转 (y)        z     y
    //     / \       - - - - - - - ->    / \   / \
    //    z   T3                       T1  T2 T3 T4
    //   / \
    // T1   T2
    private Node rightRotate(Node y) {
        Node x = y.left;
        Node T3 = x.right;
        //向右旋转过程
        x.right = y;
        y.left = T3;
        //更新height
        y.height = Math.max(getHeight(y.left), getHeight(y.right)) + 1;
        x.height = Math.max(getHeight(x.left), getHeight(x.right)) + 1;
        return x;
    }

    // 对节点y进行向左旋转操作，返回旋转后新的根节点x
    //    y                             x
    //  /  \                          /   \
    // T1   x      向左旋转 (y)       y     z
    //     / \   - - - - - - - ->   / \   / \
    //   T2  z                     T1 T2 T3 T4
    //      / \
    //     T3 T4
    private Node leftRotate(Node y) {
        Node x = y.right;
        Node T2 = x.left;
        //左旋转
        x.left = y;
        y.right = T2;
        //更新height
        y.height = Math.max(getHeight(y.left), getHeight(y.right)) + 1;
        x.height = Math.max(getHeight(x.left), getHeight(x.right)) + 1;
        return x;
    }

    @Override
    public void add(K key, V value) {
        root = add(root, key, value);
    }
    private Node add(Node node, K key, V value) {
        //向以node为根的二分搜索树中插入元素E，递归算法
        //返回插入新节点后二分搜索树的根
        if(node == null) {
            size++;
            return new Node(key, value);
        }

        if(key.compareTo(node.key) < 0) {
            node.left = add(node.left, key, value);
        }
        if(key.compareTo(node.key) > 0) {
            node.right = add(node.right, key, value);
        }
        if(key.compareTo(node.key) == 0) {
            node.value = value;
        }

        //更新height
        node.height = 1 + Math.max(getHeight(node.left), getHeight(node.right));

        //计算平衡因子
        int balanceFactor = getBalanceFactor(node);
//        if(Math.abs(balanceFactor) > 1) {
//            System.out.println("unbalanced:" + balanceFactor);
//        }

        //平衡维护
        //LL
        if(balanceFactor > 1 && getBalanceFactor(node.left) >= 0) {//右旋转
            return rightRotate(node);
        }

        //RR
        if(balanceFactor < -1 && getBalanceFactor(node.right) <= 0) {
            return leftRotate(node);
        }

        //LR，先转化为LL情况
        if(balanceFactor > 1 && getBalanceFactor(node.left) < 0) {
            node.left = leftRotate(node.left);
            return rightRotate(node);
        }

        //RL，先转化为RR情况
        if(balanceFactor < -1 && getBalanceFactor(node.right) > 0) {
            node.right = rightRotate(node.right);
            return leftRotate(node);
        }
        return node;
    }


    //返回以node为根的二分搜索树的最小值所在的节点
    private Node minimum(Node node) {
        if(node.left == null) {
            return node;
        }
        return minimum(node.left);
    }

    //从二分搜索树中删除元素为e的节点
    @Override
    public V remove(K key) {
        Node node = getNode(root, key);
        if(node != null) {
            root = remove(root, key);
            return node.value;
        }
        return null;
    }
    //删除以node为根的二分搜索树中键为key的节点，递归算法
    //返回删除节点后新的二分搜索树的根
    private Node remove(Node node, K key) {
        if(node == null) {
            return null;
        }

        Node retNode;
        if(key.compareTo(node.key) < 0) {
            node.left = remove(node.left, key);
            retNode = node;
        } else if(key.compareTo(node.key) > 0) {
            node.right = remove(node.right, key);
            retNode = node;
        } else {//key == node.key
            //待删节点左子树为空的情况
            if(node.left == null) {
                Node rightNode = node.right;
                node.right = null;
                size--;
                retNode = rightNode;
            }
            //待删节点右子树为空的情况
             else if(node.right == null) {
                Node leftNode = node.left;
                node.left = null;
                size--;
                retNode = leftNode;
            }
            //待删节点左右子树为均不为空的情况
            //找到比待删节点大的最小节点，即待删除节点右子树的最小节点
            //用这个节点顶替待删除节点的位置
            else {
                Node successor = minimum(node.right);
                successor.right = remove(node.right, successor.key);
                successor.left = node.left;
                node.left = node.right = null;
                retNode = successor;
            }
        }

        if(retNode == null) {
            return null;
        }

        //更新height
        retNode.height = 1 + Math.max(getHeight(retNode.left), getHeight(retNode.right));

        //计算平衡因子
        int balanceFactor = getBalanceFactor(retNode);

        //平衡维护
        //LL
        if(balanceFactor > 1 && getBalanceFactor(retNode.left) >= 0) {//右旋转
            return rightRotate(retNode);
        }

        //RR
        if(balanceFactor < -1 && getBalanceFactor(retNode.right) <= 0) {
            return leftRotate(retNode);
        }

        //LR，先转化为LL情况
        if(balanceFactor > 1 && getBalanceFactor(retNode.left) < 0) {
            retNode.left = leftRotate(retNode.left);
            return rightRotate(retNode);
        }

        //RL，先转化为RR情况
        if(balanceFactor < -1 && getBalanceFactor(retNode.right) > 0) {
            retNode.right = rightRotate(retNode.right);
            return leftRotate(retNode);
        }
        return retNode;

    }

    @Override
    public boolean contains(K key) {
        return getNode(root, key) != null;
    }

    @Override
    public V get(K key) {
        Node node = getNode(root, key);
        return node == null ? null : node.value;
    }

    @Override
    public void set(K key, V newValue) {
        Node node = getNode(root, key);
        if(node == null) {
            throw new IllegalArgumentException(key + " doesn't exist!");
        }
        node.value = newValue;
    }

    //返回以node为根节点的二分搜索树中，key所在的节点
    private Node getNode(Node node, K key) {
        if(node == null) {
            return null;
        }
        if(key.compareTo(node.key) == 0) {
            return node;
        } else if(key.compareTo(node.key) < 0) {
            return getNode(node.left, key);
        } else {
            return getNode(node.right, key);
        }
    }
}
```

6、BST：

```java
public class BST<K extends Comparable<K>, V> implements Map<K, V> {
    private class Node {
        public K key;
        public V value;
        public Node left, right;

        public Node(K key, V value) {
            this.key = key;
            this.value = value;
            left = null;
            right = null;
        }
    }

    private Node root;
    private int size;

    public BST() {
        this.root = null;
        this.size = 0;
    }

    @Override
    public void add(K key, V value) {
        root = add(root, key, value);
    }
    private Node add(Node node, K key, V value) {
        //向以node为根的二分搜索树中插入元素E，递归算法
        //返回插入新节点后二分搜索树的根
        if(node == null) {
            size++;
            return new Node(key, value);
        }

        if(key.compareTo(node.key) < 0) {
            node.left = add(node.left, key, value);
        }
        if(key.compareTo(node.key) > 0) {
            node.right = add(node.right, key, value);
        }
        if(key.compareTo(node.key) == 0) {
            node.value = value;
        }
        return node;
    }


    //返回以node为根的二分搜索树的最小值所在的节点
    private Node minimum(Node node) {
        if(node.left == null) {
            return node;
        }
        return minimum(node.left);
    }
    //删除以node为根的二分搜索树中的最小节点
    //返回删除节点后新的二分搜索树的根
    private Node removeMin(Node node) {
        if(node.left == null) {
            Node rightNode = node.right;
            node.right = null;
            size--;
            return rightNode;
        }
        node.left = removeMin(node.left);
        return node;
    }
    //从二分搜索树中删除元素为e的节点
    @Override
    public V remove(K key) {
        Node node = getNode(root, key);
        if(node != null) {
            root = remove(root, key);
            return node.value;
        }
        return null;
    }
    //删除以node为根的二分搜索树中键为key的节点，递归算法
    //返回删除节点后新的二分搜索树的根
    private Node remove(Node node, K key) {
        if(node == null) {
            return null;
        }
        if(key.compareTo(node.key) < 0) {
            node.left = remove(node.left, key);
            return node;
        } else if(key.compareTo(node.key) > 0) {
            node.right = remove(node.right, key);
            return node;
        } else {//key == node.key
            //待删节点左子树为空的情况
            if(node.left == null) {
                Node rightNode = node.right;
                node.right = null;
                size--;
                return rightNode;
            }
            //待删节点右子树为空的情况
            if(node.right == null) {
                Node leftNode = node.left;
                node.left = null;
                size--;
                return leftNode;
            }
            //待删节点左右子树为均不为空的情况
            //找到比待删节点大的最小节点，即待删除节点右子树的最小节点
            //用这个节点顶替待删除节点的位置
            Node successor = minimum(node.right);
            successor.right = removeMin(node.right);
            successor.left = node.left;
            node.left = node.right = null;
            return successor;
        }
    }


    @Override
    public boolean contains(K key) {
        return getNode(root, key) != null;
    }

    @Override
    public V get(K key) {
        Node node = getNode(root, key);
        return node == null ? null : node.value;
    }

    @Override
    public void set(K key, V newValue) {
        Node node = getNode(root, key);
        if(node == null) {
            throw new IllegalArgumentException(key + " doesn't exist!");
        }
        node.value = newValue;
    }

    //返回以node为根节点的二分搜索树中，key所在的节点
    private Node getNode(Node node, K key) {
        if(node == null) {
            return null;
        }
        if(key.compareTo(node.key) == 0) {
            return node;
        } else if(key.compareTo(node.key) < 0) {
            return getNode(node.left, key);
        } else {
            return getNode(node.right, key);
        }
    }

    @Override
    public int getSize() {
        return size;
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }
}
```

7、HashTable：

```java
public class HashTable<K, V> {
    private final int[] capacity
            = {53, 97, 193, 389, 769, 1543, 3079, 6151, 12289, 24593,
            49157, 98317, 196613, 393241, 786433, 1572869, 3145739, 6291469,
            12582917, 25165843, 50331653, 100663319, 201326611, 402653189, 805306457, 1610612741};//保证扩容缩容是素数

    private static final int upperTol = 10;
    private static final int lowerTol = 2;
    private int capacityIndex = 0;

    private TreeMap<K, V>[] hashtable;
    private int M;
    private int size;

    public HashTable() {
        this.M = capacity[capacityIndex];
        size = 0;
        hashtable = new TreeMap[M];
        for(int i = 0; i < M; i++) {
            hashtable[i] = new TreeMap<>();
        }
    }


    private int hash(K key) {
        return (key.hashCode() & 0x7fffffff) % M;
    }

    public int getSize() {
        return size;
    }

    public void add(K key, V value) {
        TreeMap<K, V> map = hashtable[hash(key)];
        if(map.containsKey(key)) {
            map.put(key, value);
        } else {
            map.put(key, value);
            size++;

            if(size >= upperTol * M && capacityIndex + 1 < capacity.length) {
                capacityIndex++;
                resize(capacity[capacityIndex]);
            }
        }
    }

    public V remove(K key) {
        TreeMap<K, V> map = hashtable[hash(key)];
        V ret = null;
        if(map.containsKey(key)) {
            ret = map.remove(key);
            size--;

            if(size < lowerTol * M && capacityIndex - 1 >= 0) {
                capacityIndex--;
                resize(capacity[capacityIndex]);
            }
        }
        return ret;
    }

    public void set(K key, V value) {
        TreeMap<K, V> map = hashtable[hash(key)];
        if(!map.containsKey(key)) {
            throw new IllegalArgumentException(key + " does't exist!");
        }
        map.put(key, value);
    }

    public boolean contains(K key) {
        return hashtable[hash(key)].containsKey(key);
    }

    public V get(K key) {
        return hashtable[hash(key)].get(key);
    }

    private void resize(int newM) {
        TreeMap<K, V>[] newHashTable = new TreeMap[newM];
        for(int i =0; i < newM; i++) {
            newHashTable[i] = new TreeMap<>();
        }

        int oldM = M;
        this.M = newM;
        for(int i = 0; i < oldM; i++) {
            TreeMap<K, V> map = hashtable[i];
            for(K key : map.keySet()) {
                newHashTable[hash(key)].put(key, map.get(key));
            }
        }
        this.hashtable = newHashTable;
    }
}
```

8、Map：

```java
public class LinkedListMap<K, V> implements Map<K, V> {
    private class Node {
        public K key;
        public V value;
        public Node next;

        public Node(K key, V value, Node next) {
            this.key = key;
            this.value = value;
            this.next = next;
        }

        public Node(K key) {
            this(key, null, null);
        }

        public Node() {
            this(null, null, null);
        }

        @Override
        public String toString() {
            return key.toString() + ":" + value.toString();
        }
    }
    private Node dummyHead;
    private int size;

    public LinkedListMap() {
        dummyHead = new Node();
        size = 0;
    }


    @Override
    public void add(K key, V value) {
        Node node = getNode(key);
        if(node == null) {
            dummyHead.next = new Node(key, value, dummyHead.next);
            size++;
        } else {
            node.value = value;
        }
    }

    @Override
    public V remove(K key) {
        Node prev = dummyHead;
        while (prev.next != null) {
            if(prev.next.key.equals(key)) {
                break;
            }
            prev = prev.next;
        }
        if(prev.next != null) {
            Node delNode = prev.next;
            prev.next = delNode.next;
            delNode.next = null;
            size--;
            return delNode.value;
        }
        return null;
    }

    @Override
    public boolean contains(K key) {
        return getNode(key) != null;
    }

    @Override
    public V get(K key) {
        Node node = getNode(key);
        return node == null ? null : node.value;
    }

    @Override
    public void set(K key, V newValue) {//更新键对应的值
        Node node = getNode(key);
        if(node == null) {
            throw new IllegalArgumentException(key + "does't exist!");
        }
        node.value = newValue;
    }

    @Override
    public int getSize() {
        return size;
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    private Node getNode(K key) {
        Node cur = dummyHead.next;
        while (cur != null) {
            if(cur.key.equals(key)) {
                return cur;
            }
            cur = cur.next;
        }
        return null;
    } 
}
```

9、Set：

```java
package com.set;

public class BSTSet<E extends Comparable<E>> implements Set<E> {
    private BST<E> bst;

    public BSTSet() {
        bst = new BST<>();
    }

    @Override
    public void add(E e) {
        bst.add(e);
    }

    @Override
    public void remove(E e) {
        bst.remove(e);
    }

    @Override
    public boolean contains(E e) {
        return bst.contains(e);
    }

    @Override
    public int getSize() {
        return bst.size();
    }

    @Override
    public boolean isEmpty() {
        return bst.isEmpty();
    }
}
```

10、MaxHeap：

```java
public class MaxHeap<E extends Comparable<E>> {
    private Array<E> data;
    public MaxHeap(int capacity) {
        data = new Array<>(capacity);
    }
    public MaxHeap() {
        data = new Array<>();
    }
    public MaxHeap(E[] arr) {
        data = new Array<>(arr);
        for(int i = parent(arr.length - 1); i >= 0; i--) {
            siftDown(i);
        }
    }

    //返回堆中元素个数
    public int size() {
        return data.getSize();
    }
    //返回一个布尔值，表示堆中是否为空
    public boolean isEmpty() {
        return data.isEmpty();
    }

    //返回完全二叉树的数组表示中，一个索引所表示的元素的父亲节点的索引
    private int parent(int index) {
        if(index == 0) {
            throw new IllegalArgumentException("index-0 doesn't have parent");
        }
        return (index - 1) / 2;
    }
    //返回完全二叉树的数组表示中，一个索引所表示的元素的左孩子节点的索引
    private int leftChild(int index) {
        return index * 2 + 1;
    }
    //返回完全二叉树的数组表示中，一个索引所表示的元素的右孩子节点的索引
    private int rightChild(int index) {
        return index * 2 + 2;
    }

    //向堆中添加元素
    public void add(E e) {
        data.addLast(e);
        siftUp(data.getSize() - 1);
    }
    private void siftUp(int k) {
        while (k > 0 && data.get(parent(k)).compareTo(data.get(k)) < 0) {
            data.swap(k, parent(k));
            k = parent(k);
        }
    }

    //查看堆中最大元素
    public E findMax() {
        if(data.getSize() == 0) {
            throw new IllegalArgumentException("can not findMax when heap is empty");
        }
        return data.get(0);
    }
    //取出堆中最大元素
    public E extractMax() {
        E ret = findMax();

        data.swap(0, data.getSize() - 1);
        data.removeLast();

        siftDown(0);

        return ret;
    }
    private void siftDown(int k) {
        while (leftChild(k) < data.getSize()) {
            int j = leftChild(k);
            if(j + 1 < data.getSize() && data.get(j + 1).compareTo(data.get(j)) > 0) {
                j = rightChild(k);
            }
            if(data.get(k).compareTo(data.get(j)) >= 0) {
                break;
            } else {
                data.swap(k, j);
                k = j;
            }
        }
    }

    //取出堆中的最大元素，并且替换成元素e
    public E replace(E e) {
        E ret = findMax();
        data.set(0, e);
        siftDown(0);
        return ret;
    }
}
```

11、RBTree：

```java
public class RBTree<K extends Comparable<K>, V> {

    private static final boolean RED = true;
    private static final boolean BLACK = false;

    private class Node{
        public K key;
        public V value;
        public Node left, right;
        public boolean color;

        public Node(K key, V value){
            this.key = key;
            this.value = value;
            left = null;
            right = null;
            color = RED;
        }
    }

    private Node root;
    private int size;

    public RBTree(){
        root = null;
        size = 0;
    }

    public int getSize(){
        return size;
    }

    public boolean isEmpty(){
        return size == 0;
    }

    // 判断节点node的颜色
    private boolean isRed(Node node){
        if(node == null)
            return BLACK;
        return node.color;
    }

    //   node                     x
    //  /   \     左旋转         /  \
    // T1   x   --------->   node   T3
    //     / \              /   \
    //    T2 T3            T1   T2
    private Node leftRotate(Node node){
        Node x = node.right;

        // 左旋转
        node.right = x.left;
        x.left = node;

        x.color = node.color;
        node.color = RED;

        return x;
    }

    //     node                   x
    //    /   \     右旋转       /  \
    //   x    T2   ------->   y   node
    //  / \                       /  \
    // y  T1                     T1  T2
    private Node rightRotate(Node node) {
        Node x = node.left;

        //右旋转
        node.left = x.right;
        x.right = node;

        x.color = node.color;
        node.color = RED;

        return x;
    }

    //颜色翻转
    private void flipColors(Node node) {
        node.color = RED;
        node.left.color = BLACK;
        node.right.color = BLACK;
    }

    // 向红黑树中添加新的元素(key, value)
    public void add(K key, V value){
        root = add(root, key, value);
        root.color = BLACK; // 最终根节点为黑色节点
    }

    // 向以node为根的红黑树中插入元素(key, value)，递归算法
    // 返回插入新节点后红黑树的根
    private Node add(Node node, K key, V value){

        if(node == null){
            size ++;
            return new Node(key, value); // 默认插入红色节点
        }

        if(key.compareTo(node.key) < 0)
            node.left = add(node.left, key, value);
        else if(key.compareTo(node.key) > 0)
            node.right = add(node.right, key, value);
        else // key.compareTo(node.key) == 0
            node.value = value;

        //
        if(isRed(node.right) && !isRed(node.left)) {
            node = leftRotate(node);
        }
        if(isRed(node.left) && isRed(node.left.left)) {
            node = rightRotate(node);
        }
        if(isRed(node.left) && isRed(node.right)) {
            flipColors(node);
        }

        return node;
    }


    // 返回以node为根节点的二分搜索树中，key所在的节点
    private Node getNode(Node node, K key){

        if(node == null)
            return null;

        if(key.equals(node.key))
            return node;
        else if(key.compareTo(node.key) < 0)
            return getNode(node.left, key);
        else // if(key.compareTo(node.key) > 0)
            return getNode(node.right, key);
    }

    public boolean contains(K key){
        return getNode(root, key) != null;
    }

    public V get(K key){

        Node node = getNode(root, key);
        return node == null ? null : node.value;
    }

    public void set(K key, V newValue){
        Node node = getNode(root, key);
        if(node == null)
            throw new IllegalArgumentException(key + " doesn't exist!");

        node.value = newValue;
    }

    // 返回以node为根的二分搜索树的最小值所在的节点
    private Node minimum(Node node){
        if(node.left == null)
            return node;
        return minimum(node.left);
    }

    // 删除掉以node为根的二分搜索树中的最小节点
    // 返回删除节点后新的二分搜索树的根
    private Node removeMin(Node node){

        if(node.left == null){
            Node rightNode = node.right;
            node.right = null;
            size --;
            return rightNode;
        }

        node.left = removeMin(node.left);
        return node;
    }

    // 从二分搜索树中删除键为key的节点
    public V remove(K key){

        Node node = getNode(root, key);
        if(node != null){
            root = remove(root, key);
            return node.value;
        }
        return null;
    }

    private Node remove(Node node, K key){

        if( node == null )
            return null;

        if( key.compareTo(node.key) < 0 ){
            node.left = remove(node.left , key);
            return node;
        }
        else if(key.compareTo(node.key) > 0 ){
            node.right = remove(node.right, key);
            return node;
        }
        else{   // key.compareTo(node.key) == 0

            // 待删除节点左子树为空的情况
            if(node.left == null){
                Node rightNode = node.right;
                node.right = null;
                size --;
                return rightNode;
            }

            // 待删除节点右子树为空的情况
            if(node.right == null){
                Node leftNode = node.left;
                node.left = null;
                size --;
                return leftNode;
            }

            // 待删除节点左右子树均不为空的情况

            // 找到比待删除节点大的最小节点, 即待删除节点右子树的最小节点
            // 用这个节点顶替待删除节点的位置
            Node successor = minimum(node.right);
            successor.right = removeMin(node.right);
            successor.left = node.left;

            node.left = node.right = null;

            return successor;
        }
    }
}
```



## 数据库

1、数据库并发策略？

并发控制一般采用三种方法，分别是**乐观锁和悲观锁以及时间戳**。    

- 乐观锁：
  - 乐观锁认为**一个用户读数据的时候，别人不会去写自己所读的数据**；悲观锁就刚好相反，觉得自己读数据库的时候，别人可能刚好在写自己刚读的数据，其实就是持一种比较保守的态度；时间戳就是不加锁，通过时间戳来控制并发出现的问题。
  - 一般利用表字段的version+1来实现（如SVN、GIT提交代码就是这样的）；性能高、重试失败成本不高建议乐观。
- 悲观锁：
  - 悲观锁就是**在读取数据的时候，为了不让别人修改自己读取的数据，就会先对自己读取的数据加 锁，只有自己把数据读完了，才允许别人修改那部分数据**，或者反过来说，就是自己修改某条数 据的时候，不允许别人读取该数据，只有等自己的整个事务提交了，才释放自己加上的锁，才允 许其他用户访问那部分数据。 
  - 一般是  where id=XX for update 来实现 （一般银行转账、工单审批）；性能低，但安全，失败成功高建议悲观，使用不当有死锁风险。   
  - 悲观锁所说的加“锁”，其实分为几种锁，分别是： 排它锁（写锁） 和共享锁（读锁） 。    
- 时间戳：时间戳就是**在数据库表中单独加一列时间戳**，比如“TimeStamp”， 每次读出来的时候，把该字段也读出来，当写回去的时候，把该字段加 1，提交之前 ，跟数据库的该字段比较一次，如果比数据库的值大的话，就允许保存，否则不允许保存，这种处理方法虽然不使用数据库系统提供的锁机制，但是这种方法可以大大提高数据库处理的并发量。

2、数据库事务？主键与外键的区别？

数据库事务是数据库管理系统执行过程中的一个逻辑单位，**由一个有限的数据库操作序列构成**。一个数据库事务通常包含了一个序列的对数据库的读/写操作。它的存在包含有以下两个目的： 

- **为数据库操作序列提供了一个从失败中恢复到正常状态的方法**，同时提供了数据库即使在异常状态下仍能保持一致性的方法。
- **当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。**

数据库事务拥有以下四个特性，被称之为ACID特性： 

> 原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的**操作要么全部被执行，要么都不执行。**
>
> 一致性（Consistency）：事务应确保**数据库的状态从一个一致状态转变为另一个一致状态**。在一致性状态下，所有事务对一个数据的读取结果都是相同的。 
>
> 隔离性（Isolation）：多个事务并发执行时，**一个事务的执行不应影响其他事务的执行**。一个事务所做的修改在最终提交以前，对其它事务是不可见的。 
>
> 持久性（Durability）：已**被提交的事务对数据库的修改应该永久保存在数据库中**。

主键和外键的区别： 

- 主键是**能确定一条记录的唯一标识**，比如，一条记录包括身份证号，姓名，年龄。身份证号是唯一能确定你这个人的，其他都可能有重复，所以，身份证号是主键。  
- **外键用于与另一张表的关联**。是能确定另一张表记录的字段，用于**保持数据的一致性**。 

3、数据库连接泄露的含义？

数据库连接泄露指的是如果**在某次使用或者某段程序中没有正确地关闭Connection、Statement和ResultSet资源，那么每次执行都会留下一些没有关闭的连接**，这些连接失去了引用而不能得到重新使用，因此就造成了数据库连接的泄漏。数据库连接的资源是宝贵而且是有限的，如果在某段使用频率很高的代码中出现这种泄漏，那么数据库连接资源将被耗尽，影响系统的正常运转。 

4、mysql删除语句？

- **drop语句。可以用来删除数据库和表**。

  用drop语句来删除数据库：drop database db;

  用drop语句来删除表：drop table tb;

- **delete语句。用来删除表中的行**。

  delete from tb where id=1;

  如果delete语句中没有加入where就会把表中的所有记录全部删除：

- 用**truncate来删除表中的所有行**：

  truncate table tb;

5、数据库mysql中CHAR和VCHAR的区别？

- char(n)类型：

  > char类型是**定长**的类型，即当定义的是char(10)，输入的是"abc"这三个字符时，它们占的空间一样是10个字节，包括7个空字节。当输入的字符长度超过指定的数时，char会截取超出的字符。而且，**当存储char值时，MySQL是自动删除输入字符串末尾的空格**。 char是适合存储很短的、一般固定长度的字符串。例如，char非常适合存储密码的MD5值，因为这是一个定长的值。对于非常短的列，char比varchar在存储空间上也更有效率。**取数据的时候，char类型的要用trim()去掉多余的空格，而varchar是不需要。** 

- varchar(n)类型：

  > varchar(n)类型用于存储**可变长**的，长度为n个字节的可变长度且非Unicode的字符数据。n必须是介于1和8000之间的数值，存储大小为输入数据的字节的实际长度+1/2. 比如varchar(10), 然后输入abc三个字符，那么实际存储大小为3个字节。除此之外，**varchar还需要使用1或2个额外字节记录字符串的长度**，如果列的最大长度小于等于255字节（是定义的最长长度，不是实际长度），则使用1个字节表示长度，否则使用2个字节来表示。**取数据的时候，不需要去掉多余的空格。** 

6、SQL左连接以及使用场景？

left join(左连接) 返回**包括 LEFT OUTER子句中指定的左表的所有行**，而不仅仅是联接列所匹配的行。如果左表的某行在右表中没有匹配行，则在相关联的结果集行中右表的所有选择列表列均为空值。

使用场景：可以**保持左表完整加入另一表中的数据**。

7、说说redis？使用场景？

Redis 是**速度非常快的非关系型（NoSQL）内存键值数据库**，可以存储键和五种不同类型的值之间的映射。 

**键的类型只能为字符串，值支持五种数据类型：字符串（string）、列表（list）、集合（set）、散列表（hash）、有序集合（zset）。** 这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些**操作都是原子性**的。在此基础上，redis支持各种不同方式的排序。**与memcached一样，为了保证效率，数据都是缓存在内存中**。区别的**是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步**。 

Redis 支持很多特性，例如**将内存中的数据持久化到硬盘中，使用复制来扩展读性能，使用分片来扩展写性能。** 

使用场景：

- 计数器：可以对 String 进行自增自减运算，从而实现计数器功能。 Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。 

- 缓存：将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。 

- 查找表：例如 DNS 记录就很适合使用 Redis 进行存储。 查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。 

- 消息队列：List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息。不过最好使用 Kafka、RabbitMQ 等消息中间件。 

- 会话缓存：可以使用 Redis 来统一存储多台应用服务器的会话信息。 当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。 

- 分布式锁实现：在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。

  可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。

- 其他：Set 可以实现交集、并集等操作，从而实现共同好友等功能。ZSet 可以实现有序性操作，从而实现排行榜等功能。

8、写一些基本的SQL语句？

> 选择：select * from table1 where 范围
>
> 插入：insert into table1(field1,field2) values(value1,value2)
>
> 删除：delete from table1 where 范围
>
> 更新：update table1 set field1=value1 where 范围
>
> 查找：select * from table1 where field1 like '%value1%' 
>
> 排序：select * from table1 order by field1,field2 [desc]
>
> 总数：select count as totalcount from table1
>
> 求和：select sum(field1) as sumvalue from table1
>
> 平均：select avg(field1) as avgvalue from table1
>
> 最大：select max(field1) as maxvalue from table1
>
> 最小：select min(field1) as minvalue from table1

9、count和sum的区别，以及count(*)和count(列名)的区别？

Count和sum区别：**求和用累加sum()，求行的个数用累计count**

Count（*）**包括了所有的列，在统计结果的时候不会忽略列值为null**

Count（列名）**只包括列名那一项，会忽略列值为空的计数**

10、 join作用？

> join作用是连接两个表，假设有2个表——Student表和SC表（选课表）： 
>
> - 内连接（自然连接）：当使用内连接时，如果Student中某些学生没有选课，则在SC中没有相应元组。最终查询结果舍弃了这些学生的信息 
> - 外连接：如果想以Student表为主体列出每个学生的基本情况及其选课情况。即使某个学生没有选课，依然在查询结果中显示（SC表的属性上填空值）。就需要使用外连接 

11、如何对数据库作优化？查询性能优化？

数据库优化：

- 调整数据结构的设计，**对于经常访问的数据库表建立索引**。
- **调整SQL语句**， ORACLE公司推荐使用ORACLE语句优化器（Oracle Optimizer）和行锁管理器（row-level manager）来调整优化SQL语句。
- **调整服务器内存分配**。内存分配是在信息系统运行过程中优化配置的，数据库管理员可以根据数据库运行状况调整数据库系统全局区（SGA区）的数据缓冲区、日志缓冲区和共享池的大小；还可以调整程序全局区（PGA区）的大小。
- **调整硬盘Ｉ／Ｏ**，DBA可以将组成同一个表空间的数据文件放在不同的硬盘上，做到硬盘之间Ｉ／Ｏ负载均衡。

查询性能优化：

- 使用Explain进行分析：**Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句**。 

- 优化数据访问：

  - **减少请求的数据量**：

    > - 只返回必要的列：最好不要使用 SELECT * 语句。
    > - 只返回必要的行：使用 LIMIT 语句来限制返回的数据。
    > - 缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。

  - 减少服务器端扫描的行数：最有效的方式是使用索引来覆盖查询。 

- 重构查询方式：

  - 切分大查询：一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。 
  - **分解大连接查询**：将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联。

12、事务的隔离级别？

事务的隔离性即是**同一时间只允许一个事务请求同一数据，不同事物之间彼此没有任何干扰**， 

事务隔离级别如下： 

- 读未提交：事务中的修改，即使没有提交，对其它事务也是可见的。 
- 提交读：一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。 
- 可重复读：保证在同一个事务中多次读取同样数据的结果是一样的。 
- 串行化：强制事务串行执行。 需要加锁实现，而其它隔离级别通常不需要。 

|         事务隔离级别         | 脏读 | 不可重复读 | 幻读 |
| :--------------------------: | :--: | :--------: | :--: |
| 读未提交（read-uncommitted） |  是  |     是     |  是  |
| 不可重复读（read-committed） |  否  |     是     |  是  |
| 可重复读（repeatable-read）  |  否  |     否     |  是  |
|    串行化（serializable）    |  否  |     否     |  否  |

13、并发一致性问题？

在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。 

- 丢失修改：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。 
- 读脏数据：T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。 
- 不可重复读：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。 
- 幻影读：T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。

14、三大范式？

- 第一范式（1NF）：列都是不可再分。数据库表中的所有字段值都是不可分解的原子值。 
- 第二范式（2NF）：每个表只描述一件事情。 确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。 
- 第三范式（3NF）：不存在对非主键列的传递依赖。确保数据表中的每一列数据都和主键直接相关，而不能间接相关。  

15、索引？

1）数据结构：

- B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。 
- B+ Tree 是**基于 B Tree 和叶子节点顺序访问指针进行实现**，它具有 B Tree 的平衡性，并且**通过顺序访问指针来提高区间查询的性能**。
- 在 B+ Tree 中，一个节点中的 key 从左到右非递减排列 。

![](img\B+树.PNG)

2）操作：

进行查找操作时，**首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找**。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。

插入删除操作会破坏平衡树的平衡性，因此在插入删除操作之后，需要对树进行一个分裂、合并、旋转等操作来维护平衡性。

3）与红黑树的比较：

红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下两个原因： 

> - 更少的查找次数 
>
>   平衡树查找操作的时间复杂度和树高 h 相关，O(h)=O(logdN)，其中 d 为每个节点的出度。
>
>   红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，查找的次数也就更多。
>
> - 利用磁盘预读特性
>
>   为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。
>
>   操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。并且可以利用预读特性，相邻的节点也能够被预先载入。 

16、MySQL索引？

索引（Index）是**帮助 MySQL 高效获取数据的数据结构**。索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。 

- B+Tree 索引：
  - 是大多数 MySQL 存储引擎的默认索引类型。 
  - 因为不再需要进行全表扫描，**只需要对树进行搜索即可，所以查找速度快很多**。
  - 因为 B+ Tree 的有序性，所以除了用于查找，**还可以用于排序和分组**。
  - 可以指定多个列作为索引列，多个索引列共同组成键。
  - 适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。
- 哈希索引：
  - 哈希索引能以 O(1) 时间进行查找，但是**失去了有序性**
  - **无法用于排序与分组** 
  - **只支持精确查找，无法用于部分查找和范围查找。**
- 全文索引：
  - MyISAM 存储引擎支持全文索引，用于**查找文本中的关键词，而不是直接比较是否相等**。 
  - 全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。 
- 空间数据索引：
  - MyISAM 存储引擎支持空间数据索引（R-Tree），可以**用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。**
  - 必须使用 GIS 相关的函数来维护数据。  

17、索引优点？索引使用条件？

优点：

- 大大**减少了服务器需要扫描的数据行数**。
- **帮助服务器避免进行排序和分组，以及避免创建临时表**（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。
- **将随机 I/O 变为顺序 I/O**（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。

使用条件：

- **对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效**；
- 对于**中到大型的表，索引就非常有效**；
- 但是**对于特大型的表，建立和维护索引的代价将会随之增长**。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用**分区技术**。

18、存储引擎？

数据库存储引擎**是数据库底层软件组织**，数据库管理系统（DBMS）使用数据引擎进行创建、查询、 更新和删除数据。    

InnoDB：

- 是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。
- InnoDB **底层存储结构为B+树**， B树的每个节点对应innodb的一个page， page大小是固定的， 一般设为 16k。其中非叶子节点只有键值，叶子节点包含完成数据。    

MyISAM：

- 设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。 
- 没有提供对数据库事务的支持，也不支持行级锁和外键， 因此当 INSERT(插入)或 UPDATE(更新)数据时即写操作需要锁定整个表，效率便会低一些。    

比较：

- 事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。
- 并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。
- 外键：InnoDB 支持外键。
- 备份：InnoDB 支持在线热备份。
- 崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。
- 其它特性：MyISAM 支持压缩表和空间数据索引。

19、切分与复制？

切分：

> 水平切分：
>
> - 水平切分又称为 Sharding，它是**将同一个表中的记录拆分到多个结构相同的表中**。 
> - 当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。 
>
> Sharding 策略：
>
> - 哈希取模：hash(key) % N；
> - 范围：可以是 ID 范围也可以是时间范围；
> - 映射表：使用单独的一个数据库来存储映射关系。
>
> 垂直切分：
>
> - 垂直切分是**将一张表按列切分成多个表**，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。 
> - 在数据库的层面使用垂直切分将**按数据库中表的密集程度部署到不同的库中**，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。 

复制：

- 主从复制

- 读写分离：主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。 

  读写分离能提高性能的原因在于： 

  - 主从服务器负责各自的读和写，极大程度缓解了锁的争用；
  - 从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；
  - 增加冗余，提高可用性。



## 计算机网络

根据信息在传输线上的传送方向，分为以下三种通信方式： 

- 单工通信：单向传输
- 半双工通信：双向交替传输
- 全双工通信：双向同时传输

![](img\计网体系结构.png)

1、HTTP的报文段是什么样的？

请求：

> 1、请求方法
>
> GET：请求获取Request——URL所标识的资源
>
> POST：在Request——URL所标识的资源后附加资源
>
> HEAD：请求获取由Request——URL所标识的资源的响应消息报头
>
> PUT：请求服务器存储一个资源，由Request——URL作为其标识
>
> DELETE：请求服务器删除由Request——URL所标识的资源
>
> TRACE：请求服务器回送收到的请求信息（用于测试和诊断）
>
> CONNECT：保留
>
> OPTIONS：请求查询服务器性能
>
> 2、URL
>
> URI全名为Uniform Resource Indentifier（统一资源标识），用来唯一的标识一个资源，是一个通用的概念，URI由两个主要的子集URL和URN组成。URL全名为Uniform Resource Locator（统一资源定位），通过描述资源的位置来标识资源。URN全名为Uniform Resource Name（统一资源命名），通过资源的名字来标识资源，与其所处的位置无关，这样即使资源的位置发生变动，其URN也不会变化。
>
> 3、协议版本
>
> 格式为HTTP/主版本号.次版本号，常用为：HTTP/1.1 HTTP/1.0
>
> 4、请求头部
>
> Host：接受请求的服务器地址，可以是IP或者是域名
>
> User-Agent：发送请求的应用名称
>
> Connection：指定与连接相关的属性，例如（Keep_Alive，长连接）
>
> Accept-Charset：通知服务器端可以发送的编码格式
>
> Accept-Encoding：通知服务器端可以发送的数据压缩格式
>
> Accept-Language：通知服务器端可以发送的语言

响应：

> 1、协议版本，同请求报文
>
> 2、状态码，100~199表示请求已收到继续处理，200~299表示成功，300~399表示资源重定向，400~499表示客户端请求出错，500~599表示服务器端出错
>
> 200：响应成功
>
> 302：跳转，重定向
>
> 400：客户端有语法错误
>
> 403：服务器拒绝提供服务
>
> 404：请求资源不存在
>
> 500：服务器内部错误
>
> 3、响应头部
>
> Server：服务器应用软件的名称和版本
>
> Content-Type：响应正文的类型
>
> Content-Length：响应正文的长度
>
> Content-Charset：响应正文所使用的编码
>
> Content-Encoding：响应正文使用的数据压缩格式
>
> Content-Language：响应正文使用的语言

2、HTTP用的什么连接？

**在HTTP/1.0中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接**。如果客户端浏览器访问的某个HTML或其他类型的 Web页中包含有其他的Web资源，如JavaScript文件、图像文件、CSS文件等；当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话。

但**从HTTP/1.1起，默认使用长连接，用以保持连接特性**。使用长连接的HTTP协议，会在响应头有加入这行代码：**Connection:keep-alive**

在使用长连接的情况下，**当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的 TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接**。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接要客户端和服务端都支持长连接。

3、TCP的三次握手？为什么不是两次？

![](img\三次握手.png)

第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。

第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；

第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。

**在服务端对客户端的请求进行回应(第二次握手)后，就会理所当然的认为连接已建立，而如果客户端并没有收到服务端的回应呢**？此时，客户端仍认为连接未建立，服务端会对已建立的连接保存必要的资源，如果大量的这种情况，服务端会崩溃。 

4、在浏览器中输入一个网址它的运行过程是怎样的？

- 查询DNS，获取域名对应的IP。 

  > （1）检查**浏览器缓存、检查本地hosts文件是否有这个网址的映射**，如果有，就调用这个IP地址映射，解析完成。
  >
  > （2）如果没有，则**查找本地DNS解析器缓存**是否有这个网址的映射，如果有，返回映射，解析完成。
  >
  > （3）如果没有，则查找填写或分配的首选DNS服务器，称为**本地DNS服务器**。
  >
  > （4）如果本地DNS服务器也失效：
  >
  > 如果未采用转发模式（迭代），本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后，会判断这个域名（如.com）是谁来授权管理，并返回一个负责该顶级域名服务器的IP，本地DNS服务器收到顶级域名服务器IP信息后，继续向该顶级域名服务器IP发送请求，该服务器如果无法解析，则会找到负责这个域名的下一级DNS服务器（如[http://baidu.com](http://baidu.com/)）的IP给本地DNS服务器，循环往复直至查询到映射，将解析结果返回本地DNS服务器，再由本地DNS服务器返回解析结果，查询完成。
  >
  > 如果采用转发模式（递归），则此DNS服务器就会把请求转发至上一级DNS服务器，如果上一级DNS服务器不能解析，则继续向上请求。最终将解析结果依次返回本地DNS服务器，本地DNS服务器再返回给客户机，查询完成。

- 得到目标服务器的IP地址及端口号（http 80端口，https 443端口），会调用系统库函数socket，请求一个TCP流套接字。客户端向服务器发送HTTP请求报文： 

  > （1）应用层：客户端发送HTTP请求报文。
  >
  > （2）传输层：（加入源端口、目的端口）建立连接。实际发送数据之前，三次握手客户端和服务器建立起一个TCP连接。
  >
  > （3）网络层：（加入IP头）路由寻址。
  >
  > （4）数据链路层：（加入frame头）传输数据。
  >
  > （5）物理层：物理传输bit。

- 服务器端经过物理层→数据链路层→网络层→传输层→应用层，解析请求报文，发送HTTP响应报文。  

- 客户端解析HTTP响应报文，浏览器开始显示HTML 。

- 关闭连接，TCP四次挥手。

![](img\http请求.PNG)

5、说一说http rest？

REST(Representational State Transfer)**一种轻量级的Web Service架构**。**可以完全通过HTTP协议实现**。其实现和操作比SOAP和XML-RPC更为简洁，还可以利用缓存Cache来提高响应速度，性能、效率和易用性上都优于SOAP协议。**REST架构对资源的操作包括获取、创建、修改和删除资源的操作对应HTTP协议提供的GET、POST、PUT和DELETE方法**。REST提供了一组架构约束，当作为一个整体来应用时，强调组件交互的可伸缩性、接口的通用性、组件的独立部署、以及用来减少交互延迟、增强安全性、封装遗留系统的中间组件。

REST架构约束：

**客户-服务器**（Client-Server），提供服务的服务器和使用服务的客户需要**被隔离对待**，客户和服务器之间**通过一个统一的接口来互相通讯**。

**无状态**（Stateless），服务端并不会保存有关客户的任何状态，客户端自身负责用户状态的维持，并在每次发送请求时都需要提供足够的信息。

**可缓存**（Cachable），REST系统需要能够恰当地缓存请求，以**尽量减少服务端和客户端之间的信息传输，以提高性能**。

**分层系统**（Layered System），服务器和客户之间的通信必须被这样标准化：允许服务器和客户之间的中间层（Ross：代理，网关等）可以代替服务器对客户的请求进行回应，而且这些对客户来说不需要特别支持。

**统一接口**（Uniform Interface），客户和服务器之间通信的方法必须是统一化的。

6、get和 post区别？

GET：**从指定的资源请求数据**。

POST：**向指定的资源提交要被处理的数据**。

由于HTTP的规定和浏览器/服务器的限制，导致它们在应用过程中体现出一些不同。

|                    |                            GET                             |                           POST                           |
| :----------------: | :--------------------------------------------------------: | :------------------------------------------------------: |
|   后退按钮/刷新    |                            无害                            | 数据会被重新提交（浏览器应该告知用户数据会被重新提交）。 |
|        缓存        |                          能被缓存                          |                         不能缓存                         |
|      编码方式      |                      只能进行url编码                       |                     支持多种编码方式                     |
| 是否保留在浏览历史 |                  参数保留在浏览器历史中。                  |               参数不会保存在浏览器历史中。               |
|  对数据长度的限制  | 发送数据，GET 方法向 URL 添加数据，但URL的长度是受限制的。 |                         无限制。                         |
|  对数据类型的限制  |                    只允许 ASCII 字符。                     |               没有限制。也允许二进制数据。               |
|       安全性       |            安全性较差，因为参数直接暴露在url中             |   因为参数不会被保存在浏览器历史或 web 服务器日志中。    |
|       可见性       |             数据在 URL 中对所有人都是可见的。              |                 数据不会显示在 URL 中。                  |
|      传参方式      |                     get参数通过url传递                     |                 post放在request body中。                 |

7、说一下tcp和udp的区别？

- **TCP提供面向对象的连接，通信前要建立三次握手机制的连接，UDP提供无连接的传输，传输前不用建立连接**
- **TCP提供可靠的，有序的，不丢失的传输，UDP提供不可靠的传输**
- **TCP提供面向字节流的传输，它能将信息分割成组，并在接收端将其充足，UDP提供面向数据报的传输，没有分组开销**
- **TCP提供拥塞控制，流量控制机制，UDP没有**
- **每一条TCP连接只能是点到点的；UDP支持一对一，一对多，多对一和多对多的交互通信**

8、为什么tcp可靠，哪些方法保证可靠？

1）**确认和重传机制**

建立连接时三次握手同步双方的“序列号 + 确认号 + 窗口大小信息”，是确认重传、流控的基础

传输过程中，如果Checksum校验失败、丢包或延时，发送端重传。

2）**数据排序**

TCP有专门的序列号SN字段，可提供数据re-order

3）**流量控制**

滑动窗口和计时器的使用。TCP窗口中会指明双方能够发送接收的最大数据量，**发送方通过维持一个发送滑动窗口来确保不会发生由于发送方报文发送太快接收方无法及时处理的问题**。

4） **拥塞控制**

TCP的拥塞控制由4个核心算法组成：

“慢启动”（Slow Start）

“拥塞避免”（Congestion avoidance）

“快速重传 ”（Fast Retransmit）

“快速恢复”（Fast Recovery）

**如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高**。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而**拥塞控制是为了降低整个网络的拥塞程度**。 

> 慢开始与拥塞避免：
>
> 发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 ...
>
> 注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd >= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。
>
> 如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。
>
> 快重传与快恢复：
>
> 在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。
>
> 在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。
>
> 在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。
>
> 慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。

9、说一说TCP的流量控制？

滑动窗口机制：

滑动窗口协议的基本原理就**是在任意时刻，发送方都维持了一个连续的允许发送的帧的序号，称为发送窗口；同时，接收方也维持了一个连续的允许接收的帧的序号，称为接收窗口**。发送窗口和接收窗口的序号的上下界不一定要一样，甚至大小也可以不同。不同的滑动窗口协议窗口大小一般不同。发送方窗口内的序列号代表了那些已经被发送，但是还没有被确认的帧，或者是那些可以被发送的帧。

举例：

![](img\滑动窗口.png)

发送和接受方都会维护一个数据帧的序列，这个序列被称作窗口。发送方的窗口大小由接受方确定，目的在于控制发送速度，以免接受方的缓存不够大，而导致溢出，同时控制流量也可以避免网络拥塞。图中的4,5,6号数据帧已经被发送出去，但是未收到关联的ACK，7,8,9帧则是等待发送。可以看出发送端的窗口大小为6，这是由接受端告知的（事实上必须考虑拥塞窗口cwnd，这里暂且考虑cwnd>rwnd）。此时如果发送端收到4号ACK，则窗口的左边缘向右收缩，窗口的右边缘则向右扩展，此时窗口就向前“滑动了”，即数据帧10也可以被发送。

10、ipv6的位数？

IPv6的128位地址通常写成8组，每组由四个十六进制数组成。 

11、说一说osi七层模型？

物理层（比特流）：设备之间比特流的传输。    

> 在OSI参考模型中，物理层（Physical Layer）是参考模型的最低层，也是OSI模型的第一层。
>
> 物理层的主要功能是：**利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。**
>
> 物理层的作用是**实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异**。使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。

数据链路层（帧）：将上层数据封装成帧，用 MAC 地址访问媒介，错误检测与修正。    

> 数据链路层（Data Link Layer）是OSI模型的第二层，**负责建立和管理节点间的链路**。该层的主要功能是：**通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。**
>
> 在计算机网络中由于各种干扰的存在，物理链路是不可靠的。因此，这一层的主要功能是在物理层提供的比特流的基础上，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路，即提供可靠的通过物理介质传输数据的方法。
>
> 该层通常又被分为介质访问控制（MAC）和逻辑链路控制（LLC）两个子层。
>
> MAC子层的主要任务是解决共享型网络中多用户对信道竞争的问题，完成网络介质的访问控制；
>
> LLC子层的主要任务是建立和维护网络连接，执行差错校验、流量控制和链路控制。
>
> 数据链路层的具体工作是接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层；并且，还负责处理接收端发回的确认帧的信息，以便提供可靠的数据传输。

网络层（包）：提供逻辑地址（IP）、选路，数据从源端到目的端的传输。    

> 网络层（Network Layer）是OSI模型的第三层，它是OSI参考模型中最复杂的一层，也是通信子网的最高一层。它**在下两层的基础上向资源子网提供服务**。其主要任务是：**通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。该层控制数据链路层与传输层之间的信息转发，建立、维持和终止网络的连接。**具体地说，数据链路层的数据在这一层被转换为数据包，然后通过路径选择、分段组合、顺序、进/出路由等控制，将信息从一个网络设备传送到另一个网络设备。
>
> 一般地，数据链路层是解决同一网络内节点之间的通信，而网络层主要解决不同子网间的通信。例如在广域网之间通信时，必然会遇到路由（即两节点间可能有多条路径）选择问题。
>
> 在实现网络层功能时，需要解决的主要问题如下：
>
> 寻址：数据链路层中使用的物理地址（如MAC地址）仅解决网络内部的寻址问题。在不同子网之间通信时，为了识别和找到网络中的设备，每一子网中的设备都会被分配一个唯一的地址。由于各子网使用的物理技术可能不同，因此这个地址应当是逻辑地址（如IP地址）。
>
> 交换：规定不同的信息交换方式。常见的交换技术有：线路交换技术和存储转发技术，后者又包括报文交换技术和分组交换技术。
>
> 路由算法：当源节点和目的节点之间存在多条路径时，本层可以根据路由算法，通过网络为数据分组选择最佳路径，并将信息从最合适的路径由发送端传送到接收端。
>
> 连接服务：与数据链路层流量控制不同的是，前者控制的是网络相邻节点间的流量，后者控制的是从源节点到目的节点间的流量。其目的在于防止阻塞，并进行差错检测。

传输层（段）：实现网络不同主机上用户进程之间的数据通信，可靠与不可靠的传输，传输层的错误检测，流量控制等。    

> **OSI下3层的主要任务是数据通信，上3层的任务是数据处理**。而传输层（Transport Layer）是OSI模型的第4层。因此该层**是通信子网和资源子网的接口和桥梁**，起到承上启下的作用。
>
> 该层的主要任务是：**向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输**。传输层的作用是向高层屏蔽下层数据通信的细节，即向用户透明地传送报文。该层常见的协议：TCP/IP中的TCP协议、Novell网络中的SPX协议和微软的NetBIOS/NetBEUI协议。
>
> 传输层提供会话层和网络层之间的传输服务，这种服务从会话层获得数据，并在必要时，对数据进行分割。然后，传输层将数据传递到网络层，并确保数据能正确无误地传送到网络层。因此，传输层负责提供两节点之间数据的可靠传送，当两节点的联系确定之后，传输层则负责监督工作。综上，传输层的主要功能如下：
>
> 传输连接管理：提供建立、维护和拆除传输连接的功能。传输层在网络层的基础上为高层提供“面向连接”和“面向无接连”的两种服务。
>
> 处理传输差错：提供可靠的“面向连接”和不太可靠的“面向无连接”的数据传输服务、差错控制和流量控制。在提供“面向连接”服务时，通过这一层传输的数据将由目标设备确认，如果在指定的时间内未收到确认信息，数据将被重发。
>
> 监控服务质量。

会话层（数据）：提供包括访问验证和会话管理在内的建立和维护应用之间通信的机 制，如服务器验证用户登录便是由会话层完成的。    

> 会话层（Session Layer）是OSI模型的第5层，是用户应用程序和网络之间的接口，主要任务是：**向两个实体的表示层提供建立和使用连接的方法。**将不同实体之间的表示层的连接称为会话。因此会话层的任务就是组织和协调两个会话进程之间的通信，并对数据交换进行管理。
>
> 用户可以按照半双工、单工和全双工的方式建立会话。当建立会话时，用户必须提供他们想要连接的远程地址。而这些地址与MAC（介质访问控制子层）地址或网络层的逻辑地址不同，它们是为用户专门设计的，更便于用户记忆。域名（DN）就是一种网络上使用的远程地址例如：[www.3721.com](http://www.3721.com/)就是一个域名。会话层的具体功能如下：
>
> 会话管理：允许用户在两个实体设备之间建立、维持和终止会话，并支持它们之间的数据交换。例如提供单方向会话或双向同时会话，并管理会话中的发送顺序，以及会话所占用时间的长短。
>
> 会话流量控制：提供会话流量控制和交叉会话功能。
>
> 寻址：使用远程地址建立会话连接。
>
> 出错控制：从逻辑上讲会话层主要负责数据交换的建立、保持和终止，但实际的工作却是接收来自传输层的数据，并负责纠正错误。会话控制和远程过程调用均属于这一层的功能。但应注意，此层检查的错误不是通信介质的错误，而是磁盘空间、打印机缺纸等类型的高级错误。

表示层（数据）：主要解决拥护信息的语法表示问题，如加密解密。    

> 表示层（Presentation Layer）是OSI模型的第六层，它对来自应用层的命令和数据进行解释，对各种语法赋予相应的含义，并按照一定的格式传送给会话层。其主要功能是“**处理用户信息的表示问题，如编码、数据格式转换和加密解密”等**。表示层的具体功能如下：
>
> 数据格式处理：协商和建立数据交换的格式，解决各应用程序之间在数据格式表示上的差异。
>
> 数据的编码：处理字符集和数字的转换。例如由于用户程序中的数据类型（整型或实型、有符号或无符号等）、用户标识等都可以有不同的表示方式，因此，在设备之间需要具有在不同字符集或格式之间转换的功能。
>
> 压缩和解压缩：为了减少数据的传输量，这一层还负责数据的压缩与恢复。
>
> 数据的加密和解密：可以提高网络的安全性。

应用层（数据）：确定进程之间通信的性质以满足用户需要以及提供网络与用户应用。    

> 应用层（Application Layer）是OSI参考模型的最高层，它是计算机用户，以及各种应用程序和网络之间的接口，其功能是**直接向用户提供服务，完成用户希望在网络上完成的各种工作**。它在其他6层工作的基础上，负责完成网络中应用程序与网络操作系统之间的联系，建立与结束使用者之间的联系，并完成网络用户提出的各种网络服务及应用所需的监督、管理和服务等各种协议。此外，该层还负责协调各个应用程序间的工作。
>
> 应用层为用户提供的服务和协议有：文件服务、目录服务、文件传输服务（FTP）、远程登录服务（Telnet）、电子邮件服务（E-mail）、打印服务、安全服务、网络管理服务、数据库服务等。上述的各种网络服务由该层的不同应用协议和程序完成，不同的网络操作系统之间在功能、界面、实现技术、对硬件的支持、安全可靠性以及具有的各种应用程序接口等各个方面的差异是很大的。应用层的主要功能如下：
>
> 用户接口：应用层是用户与网络，以及应用程序与网络间的直接接口，使得用户能够与网络进行交互式联系。
>
> 实现各种服务：该层具有的各种应用程序可以完成和实现用户请求的各种服务。

12、DNS解析过程？

- **浏览器先检查自身缓存中有没有被解析过的这个域名对应的ip地址**，如果有，解析结束。同时域名被缓存的时间也可通过TTL属性来设置。
- 如果浏览器缓存中没有（专业点叫还没命中），**浏览器会检查操作系统缓存中有没有对应的已解析过的结果**。而操作系统也有一个域名解析的过程。在windows中可通过c盘里一个叫hosts的文件来设置，如果你在这里指定了一个域名对应的ip地址，那浏览器会首先使用这个ip地址。
- 如果至此还没有命中域名，才会**真正的请求本地域名服务器（LDNS）来解析这个域名**，这台服务器一般在你的城市的某个角落，距离你不会很远，并且这台服务器的性能都很好，一般都会缓存域名解析结果，大约80%的域名解析到这里就完成了。
- 如果LDNS仍然没有命中，就**直接跳到Root Server 域名服务器请求解析**
- 根域名服务器返回给LDNS一个所查询域的主域名服务器（gTLD Server，国际顶尖域名服务器，如.com .cn .org等）地址
- 此时LDNS再发送请求给上一步返回的gTLD
- 接受请求的gTLD查找并返回这个域名对应的Name Server的地址，这个Name Server就是网站注册的域名服务器
- Name Server根据映射关系表找到目标ip，返回给LDNS
- LDNS缓存这个域名和对应的ip
- LDNS把解析的结果返回给用户，用户根据TTL值缓存到本地系统缓存中，域名解析过程至此结束

13、说一说http和https区别？

**HTTP协议传输的数据都是未加密的，也就是明文的**，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了**SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS**。简单来说，**HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全**。

HTTPS和HTTP的区别主要如下：

- **https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。**
- **http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。**
- **http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。**
- **http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。**

14、说一说TCP断连过程，以及单向连接关闭后还能否通信？

**由于TCP连接是全双工的，因此每个方向都必须单独进行关闭**。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。**收到一个 FIN只意味着这一方向上没有数据流动**，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。四次挥手过程：

![](img\四次挥手.jpg)

（1）客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。

（2）服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。

（3）服务器B关闭与客户端A的连接，发送一个FIN给客户端A。

（4）客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。

四次挥手原因：这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。但**关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET**,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。

15、说说HTTP常见头？

> - Accept：text/html, application/xhtml+xml, application/xml;q=0.9, image/webp, image/apng, */*; q=0.8 
>
>   作用：向服务器申明客户端（浏览器）可以接受的媒体类型（MIME）的资源
>
>   解释：浏览器可以接受text/html、application/xhtml+xml、application/xml类型，通配符*/* 表示任意类型的数据。并且浏览器按照该顺序进行接收。( text/html —> application/xhtml+xml —> application/xml)
>
> - Accept-encoding: gzip, deflate, br
>
>   作用：向服务器申明客户端（浏览器）接收的编码方法，通常为压缩方法
>
>   解释：浏览器支持采用经过gzip，deflate 或 br 压缩过的资源
>
> - Accept-Language: en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7
>
>   作用：向服务器申明客户端（浏览器）接收的语言
>
>   解释：浏览器能够接受en-US, en 和 zh-CN 三种语言，其中 en-US 的权重最高 ( q 最高为1，最低为 0)，服务器优先返回 en-US 语言
>
>   延伸：语言与字符集的区别：zh-CN 为汉语，汉语中有许多的编码：gbk2312 等
>
> - Cache-control: max-age=0
>
>   作用：控制浏览器的缓存，常见值为private、no-cache、max-age、alidate，默认为 private，根据浏览器查看页面不同的方式来进行区别
>
>   解释：浏览器在访问了该页面后，不再会访问服务器
>
> - Cookie:
>
>   作用：告诉服务器关于Session 的信息，存储让服务器辨识用户身份的信息。
>
> - Refer：<https://www.baidu.com/xxxxxxxxxx>
>
>   作用：告诉服务器该页面从哪个页面链接的
>
>   解释：该页面从[https://www.baidu.com](https://www.baidu.com/) 中的搜索结果中点击过来的
>
> - Upgrade-insecure-requests：1
>
>   作用：申明浏览器支持从http 请求自动升级为 https 请求，并且在以后发送请求的时候都使用 https
>
>   解释：当页面中包含大量的http 资源的时候（图片、iframe），如果服务器发现一旦存在上述的响应头的时候，会在加载 http 资源的时候自动替换为 https 请求
>
> - User-agent：Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36
>
>   作用：向服务器发送浏览器的版本、系统、应用程序的信息。
>
>   解释：Chrome 浏览器的版本信息为 63.0.3239.132，并将自己伪装成 Safari，使用的是 WebKit 引擎，WebKit伪装成 KHTML，KHTML伪装成Gecko（伪装是为了接收那些为Mozilla、safari、gecko编写的界面）
>
>   延伸：可以随便填（但不应该随便填）不过一般用于统计。
>
> - X-Chrome-UMA-Enabled、X-Client-Data ：与 Chrome 浏览器相关的数据
>
>   Response Headers

16、说说HTTP状态码？

状态码，100~199表示请求已收到继续处理，200~299表示成功，300~399表示资源重定向，400~499表示客户端请求出错，500~599表示服务器端出错

> 200：响应成功
>
> 302：跳转，重定向
>
> 400：客户端有语法错误
>
> 403：服务器拒绝提供服务
>
> 404：请求资源不存在
>
> 500：服务器内部错误

17、说说soket编程和http协议？

由于**通常情况下Socket连接就是TCP连接，因此Socket连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开**。但在实际网络应用中，客户端到服务器之间的通信往往需要穿越多个中间节点，例如路由器、网关、防火墙等，大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致 Socket 连接断连，因此需要通过轮询告诉网络，该连接处于活跃状态。

而**HTTP连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据**。

很多情况下，需要服务器端主动向客户端推送数据，保持客户端与服务器数据的实时与同步。此时若双方建立的是Socket连接，服务器就可以直接将数据传送给客户端；若双方建立的是HTTP连接，则服务器需要等到客户端发送一次请求后才能将数据传回给客户端，因此，客户端定时向服务器端发送连接请求，不仅可以保持在线，同时也是在“询问”服务器是否有新的数据，如果有就将数据传给客户端。

18、搜索敏感词汇时，页面被重置的原理？

根据TCP协议的规定，**用户和服务器建立连接需要三次握手**：第一次握手用户向服务器发送SYN数据包发出请求（SYN, x:0），第二次握手服务器向用户发送SYN/ACK数据包发出回应（SYN/ACK, y:x+1），第三次握手用户向服务器发送ACK数据包发出确认（ACK, x+1:y+1），至此一个TCP连接建立成功。其中x为用户向服务器发送的序列号，y为服务器向用户发送的序列号。

**关键字检测，针对明文或者base64等弱加密通讯内容，与准备好的敏感词库进行匹配，当发现敏感词时，将服务器发回的SYN/ACK包改成SYN/ACK, Y:0，这代表TCP连接被重置，用户便主动放弃了连接，提示连接失败。让用户误认为服务器拒绝连接，而主动放弃继续与服务器连接，自动阻断记录含有敏感词的网页。**

19、说一说两个机器之间的通讯过程？以及计算机网络为什么有七层？

PC1 首先判断目标ip是否和自己在同一网段，是就进行[ARP](https://www.baidu.com/s?wd=ARP&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)广播，解析出MAC地址。不是，则将网关的MAC地址作为MAC地址。

PC1封装的数据包括目标、源的端口号、IP、MAC地址。

交换机收到数据后，对比MAC地址表，知道从哪个口发出数据。

路由收到数据后根据路由表将数据发往下一个目标地。

最后一个路由通过ARP解析出PC2的MAC地址。

路由封装的数据包括目标、源的端口号、IP、MAC地址。

建立七层模型的主要目的是为**解决异种网络互连时所遇到的兼容性问题**。它的最大优点是**将服务、接口和协议这三个概念明确地区分开来**：**服务说明某一层为上一层提供一些什么功能，接口说明上一层如何使用下层的服务，而协议涉及如何实现本层的服务**；这样各层之间具有很强的独立性，互连网络中各实体采用什么样的协议是没有限制的，只要向上提供相同的服务并且不改变相邻层的接口就可以了。网络七层的划分也是为了**使网络的不同功能模块（不同层次）分担起不同的职责**，从而带来如下好处： 

- **减轻问题的复杂程度**，一旦网络发生故障，可迅速定位故障所处层次，便于查找和纠错； 
- **在各层分别定义标准接口，使具备相同对等层的不同网络设备能实现互操作，各层之间则相对独立，一种高层协议可放在多种低层协议上运行**； 
- **能有效刺激网络技术革新**，因为每次更新都可以在小范围内进行，不需对整个网络动大手术；

20、请你说一说什么是http协议，http的数据段包括什么？http 为什么是无状态的？ip地址的abcd类是怎样分的，ABCD分层协议为什么如此分层，什么是长连接和短链接？

什么是http协议？

**http（hyperText transport Protocol）是超文本传输协议的缩写，它用于传送www方式的数据，关于http协议采用了请求/响应模型，客户端向服务器发送了一个请求，服务器以一个状态行作为响应**

http的数据段包括什么？

通常http消息包括**客户机向服务器请求消息和服务器向客户机的响应消息**，这两种类型的消息由一个起始行，一个或多个头域，一个指示头域结束的空行和可选的消息体组成，http的头域包括通用头，请求头，响应头，和实体头四个部分，每个头域由一个域名，冒号，和域值三部分组成，域名是大小写无关的，域值前可以添加任何数量的空格符，头域可以被扩张成多行，在每行开始处，使用至少一个空格或制表符。

http为什么是无状态的？

**无状态是指协议对于事务处理没有记忆能力**，因为http协议目的在于支持超文本的传输，更加广义一点就是支持资源的传输，那么在客户端浏览器向服务器发送请求，继而服务器将相应的资源发回客户这样一个过程中，无论对于客户端还是服务器，都没有必要记录这个过程，因为**每一次请求和响应都是相对独立的**，一般而言，一个url对应唯一的超文本，正因为这样d唯一性，所以http协议被设计为无状态的链接协议符合他本身的需求。

ip地址的abcd类是怎样分的

A类地址的表示范围是：0.0.0.0-126.255.255.255，默认网络掩码为：255.0.0.0，A类地址分配给规模特别大的网络使用，

B类地址表示范围是：128.0.0.0-191.255.255.255，默认网络掩码为欸：255.255.0.0，B类地址分配给一般的中型网络

C类地址的表示范围是192.0.0.0-223.255.255.255，默认网络掩码是：255.255.255.0，C类地址分配给小型网络，如局域网

D类地址称为广播地址，共特殊协议向选定的节点发送信息使用。

这样便于寻址和层次化的构造网络。

什么是长连接和短连接?

**http1.0中默认使用短连接，服务器和客户端没进行一次http操作，就建立一次连接，任务结束就终端连接，http1.1起。默认使用长连接，用以保持连接特性，当一个网页打开完成后，服务器和客户端之间用于传输http数据的tcp连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立好的连接。**

21、tcp数据段都包括什么？

![](img\tcp报文段格式.png)

> 源端口（Source port） 和 目的端口（Destination port）：
>
> 字段标明了一个连接的两个端点用来跟踪同一时间内通过网络的不同会话。一般每个端口对应一个应用程序
>
> 序列号(Sequence number)：字节号 (32 位)，表示一个字节的编号
>
> 初始序列号ISNs(initial sequence numbers )：随机产生的
>
> SYN：携带了ISNs 和SYN 控制位的数据段
>
> 确认号（Acknowledgement number）：期望接收的字节号 (32位)
>
> TCP段头长度（TCP header length）： TCP段头长度， 单位32位（4字节）
>
> 保留域/字段：逐步启用,如做拥塞控制等
>
> URG：当紧急指针使用的时候，URG 被置为1。紧急指针是一个对于当前序列号的字节偏移量，标明紧急数据从哪里开始
>
> 当URG=1时，表明有紧急数据，必须首先处理收方收到这样的数据后，马上处理，处理完后恢复正常操作即使win=0，也可以发送这样的数据
>
> ACK：为1 表示确认号有效，为0 标明确认号无效
>
> PSH：表示这是带有PUSH标志的数据，接收方收到这样的数据，应该立刻送到上层，而不需要缓存它
>
> RST：被用来重置一个已经混乱的连接
>
> SYN：用在连接建立过程中
>
> SYN=1，ACK=0 连接请求，当SYN=1，ACK=1 连接接受
>
> FIN： 被用来释放连接，它表示发送方已经没有数据要传输了，但是可以继续接收数据
>
> Window size： 告诉对方可以发送的数据字节数，从确认字节号开始（决定于接收方）
>
> Checksum：提供额外的可靠性，校验的范围包括头部、数据和概念性的伪头部
>
> 选项域：选项域提供了一种增加基本头没有包含内容的方法

22、说一下tcp/ip四层网络协议？

TCP/IP四层网络协议分别是应用层，网络层，传输层，数据链路层 。

23、从打开浏览器输入url到到达服务器上项目中某一个Controller上，请你来描述一下这一串过程？

这个过程中发生了网络通信，即**利用ｔｃｐ／ｉｐ协议簇进行网络通信，发送端由应用层往下走，接收端由数据链路层往上走**，步骤如下：

- 浏览器输入ｕｒｌ，其中http是协议
- 应用层DNS解析，返回对应的ip地址
- 应用层客户端发送http请求，
- 网络层ip查询ｍａｃ地址，
- 传输层ｔｃｐ传输报文
- 数据到达数据链路层，此时客户端发送请求结束
- 服务器在数据链路层收到数据包，再层层下上直到应用层，
- 服务器响应请求，查找客户端请求的资源并返回响应报文

24、介绍下session？

**Session：在web开发中，服务器可以为每个用户创建一个会话对象(session对象)**，默认情况下一个浏览器独占一个session对象，因此在需要保存用户数据时，服务器程序可以把用户数据写到用户浏览器独占的session中，当用户使用浏览器访问其他程序时，其他程序可以从用户的session中取出该用户的数据，为用户服务，其实现原理是服务器创建session出来后，会把session的id号，以cookie的形式回写给客户机，这样**只要客户机的浏览器不关，再去访问服务器时，都会带着session的id号去，服务器发现客户机浏览器带session id过来了，就会使用内存中与之对应的session服务**。

Session和cookie的区别：

- cookie是把用户的数据写给用户浏览器
- session是把用户的数据写到用户独占的session中
- session对象由服务器创建，开发人员可以调用request对象的getsession方法得到session对象

25、请你来回答一下，比如淘宝的搜索算法，输入关键词，会给出搜索出来的商品结果，对于这样的算法，如何评价它的好坏？

淘宝的搜索算法： 

- **目标性比较强**，当然，这个相对而言，从query来看，用户对目标商品的认知度相对较强
- 短query/符合query较多，传统搜索引擎里的xxx的商品这种query较少，当然，这与淘宝搜索的处理能力也有关系，用户对query进行分词的情况很常见
- 属性类query较为常见，如雪纺、鱼嘴等等表明用户特征的query较为常见
- **用户对结果的判断**，基本上是价格敏感+信用敏感+销量敏感，其中销量敏感和信用敏感其实是一回事

26、信道复用技术？

- 频分复用：频分复用的所有主机在相同的时间占用不同的频率带宽资源。 
- 时分复用：时分复用的所有主机在不同的时间占用相同的频率带宽资源。 
- 统计时分复用：是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送。 
- 波分复用：光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波。 
- 码分复用：为每个用户分配 m bit 的码片，并且所有的码片正交 。

27、CSMA/CD协议？

CSMA/CD 表示载波监听多点接入 / 碰撞检测 :

- **多点接入** ：说明这是**总线型网络，许多主机以多点的方式连接到总线上**。
- **载波监听** ：**每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。**
- **碰撞检测** ：**在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。**

28、IP地址编址方式？

1）分类：由两部分组成，**网络号和主机号**，其中不同分类具有不同的网络号长度，并且是固定的。

​		  IP 地址 ::= {< 网络号 >, < 主机号 >}

![](img\ip_分类.png)

2）子网划分：通过**在主机号字段中拿一部分作为子网号**，把两级 IP 地址划分为三级 IP 地址。 

​			  IP 地址 ::= {< 网络号 >, < 子网号 >, < 主机号 >} 

3）无分类：无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，**使用网络前缀和主机号来对 IP 地址进行编码**，网络前缀的长度可以根据需要变化。 

​		          IP 地址 ::= {< 网络前缀号 >, < 主机号 >} 

29、地址解析协议ARP？ARP 高效运行的关键是什么？    

ARP 实现由 IP 地址得到 MAC 地址。 

每个主机都有一个 ARP 高速缓存，里面有**本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表**。 

如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时**主机 A 通过广播的方式发送 ARP 请求分组**，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。 

ARP 高效运行的关键是**每个主机上都有一个 ARP 的高速缓存**。    

30、网络地址转换NAT？

专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以**使用 NAT 来将本地 IP 转换为全球 IP。** 

31、路由器分组转发流程？

- 从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。
- 若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付；
- 若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器；
- 若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器；
- 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；
- 报告转发分组出错。

32、路由选择协议？

自治系统内部的路由选择：RIP 和 OSPF；自治系统间的路由选择：BGP

- 内部网关协议 RIP：RIP 是一种**基于距离向量的路由选择协议**。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。 RIP **按固定的时间间隔仅和相邻路由器交换自己的路由表**，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。 
- 内部网关协议OSPF：**开放最短路径优先 OSPF**，是为了克服 RIP 的缺点而开发出来的。**向本自治系统中的所有路由器发送信息**，这种方法是洪泛法。**发送的信息就是与相邻路由器的链路状态**，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。**只有当链路状态发生变化时，路由器才会发送信息。**
- 外部网关协议BGP：BGP 只能寻找一条比较好的路由，而不是最佳路由。 

33、加密？

- 对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。
  - 优点：运算速度快；
  - 缺点：无法安全地将密钥传输给通信方。 
- 非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥 。
  - 优点：可以更安全地将公开密钥传输给通信发送方；
  - 缺点：运算速度慢。

34、I/O模型？

对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待数据到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。 

- 阻塞式I/O：**应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回**。在阻塞的过程中，其它应用进程还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其它应用进程还可以执行，所以不消耗 CPU 时间，这种模型的 **CPU 利用率会比较高**。 

- 非阻塞式I/O：应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询（polling）。 由于 **CPU 要处理更多的系统调用，因此这种模型的 CPU 利用率比较低**。 

- I/O复用：使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中。

  它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O。

- 信号驱动I/O：应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。

  相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高。

- 异步I/O：应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。

  异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。

35、I/ O复用？

select/poll/epoll 都是 **I/O 多路复用的具体实现**，select 出现的最早，之后是 poll，再是 epoll。 

1）select：select 允许应用程序监视一组文件描述符，等待一个或者多个描述符成为就绪状态，从而完成 I/O 操作。 

2）poll：poll 的功能与 select 类似，也是等待一组描述符中的一个成为就绪状态。 

比较：

- 功能：select 和 poll 的功能基本相同，不过在一些实现细节上有所不同。 
  - select 会修改描述符，而 poll 不会；
  - select 的描述符类型使用数组实现，FD_SETSIZE 大小默认为 1024，因此默认只能监听 1024 个描述符。如果要监听更多描述符的话，需要修改 FD_SETSIZE 之后重新编译；而 poll 没有描述符数量的限制；
  - poll 提供了更多的事件类型，并且对描述符的重复利用上比 select 高。
  - 如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定。
- 速度：select 和 poll 速度都比较慢，每次调用都需要将全部描述符从应用进程缓冲区复制到内核缓冲区。 
- 可移植性：几乎所有的系统都支持 select，但是只有比较新的系统支持 poll。 

3）epoll：epoll 只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，并且进程不需要通过轮询来获得事件完成的描述符。epoll 仅适用于 Linux OS。  epoll 比 select 和 poll 更加灵活而且没有描述符数量限制。 epoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符也不会产生像 select 和 poll 的不确定情况。 

36、如何理解 IP 的不可靠和无连接 ？

不可靠：指的是**不能保证数据报能成功地到达目的地**。 发生错误时候，丢弃该数据包，发送 ICMP 消息给信源端。 可靠性由上层提供。 

无连接： IP 不维护关于后续数据报的状态信息。 体现在， IP 数据可以不按顺序发送和接收。 A 发送连续的数据报，到达 B 不一定是连续的， 来回路由选择可能不一样，路线也不一样，到达先后顺序也不一样。

37、ICMP 报文的分类？

ICMP 分为两类，一类是 ICMP 查询报文，另一类是 ICMP 差错报文。

|   ICMP报文   | 类型的值 |  ICMP报文的类型  |
| :----------: | :------: | :--------------: |
| 差错报告报文 |    3     |    终点不可达    |
| 差错报告报文 |    4     |     源点抑制     |
| 差错报告报文 |    11    |     时间超过     |
| 差错报告报文 |    12    |     参数问题     |
| 差错报告报文 |    5     |     改变路由     |
|   询问报文   |   8或0   |  回送请求或回答  |
|   询问报文   |  13或14  | 时间戳请求或回答 |

38、http2.0 和 http1.1 的区别 ？

![](img\http2.0_http1.1.PNG)



## 操作系统

1、说一下多进程、多线程，操作系统层面的差别和联系？

进程：进程是一个**具有一定独立功能的程序在一个数据集上的一次动态执行的过程**，**是操作系统进行资源分配和调度的一个独立单位**，是应用程序运行的载体。进程是一种抽象的概念，从来没有统一的标准定义。**进程一般由程序、数据集合和进程控制块三部分组成**。程序用于描述进程要完成的功能，是控制进程执行的指令集；数据集合是程序在执行时所需要的数据和工作区；程序控制块(Program Control Block，简称PCB)，包含进程的描述信息和控制信息，是进程存在的唯一标志。

线程：在早期的操作系统中并没有线程的概念，**进程是能拥有资源和独立运行的最小单位，也是程序执行的最小单位**。任务调度采用的是时间片轮转的抢占式调度方式，而进程是任务调度的最小单位，每个进程有各自独立的一块内存，使得各个进程之间内存地址相互隔离。后来，随着计算机的发展，对CPU的要求越来越高，进程之间的切换开销较大，已经无法满足越来越复杂的程序的要求了。于是就发明了线程，线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位**。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间**(也就是所在进程的内存空间)。一个标准的线程由线程ID、当前指令指针(PC)、寄存器和堆栈组成。而进程由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成。

差别：1.**线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位**；2.**一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线**；3.**进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间**(包括代码段、数据集、堆等)及一些进程级的资源(如打开文件和信号)，某进程内的线程在其它进程不可见；4.**调度和切换：线程上下文切换比进程上下文切换要快得多**。

联系：原则上一个CPU只能分配给一个进程，以便运行这个进程。通常使用的计算机中只有一个CPU，同时运行多个进程，就必须使用并发技术。通常采用时间片轮转进程调度算法，在操作系统的管理下，所有正在运行的进程轮流使用CPU，每个进程允许占用CPU的时间非常短(比如10毫秒)，这样用户根本感觉不出来CPU是在轮流为多个进程服务，就好象所有的进程都在不间断地运行一样。但实际上在任何一个时间内有且仅有一个进程占有CPU。如果一台计算机有多个CPU，情况就不同了，如果进程数小于CPU数，则不同的进程可以分配给不同的CPU来运行，这样，多个进程就是真正同时运行的，这便是并行。但如果进程数大于CPU数，则仍然需要使用并发技术。在Windows中，进行CPU分配是以线程为单位的，一个进程可能由多个线程组成。操作系统将CPU的时间片分配给多个线程,每个线程在操作系统指定的时间片内完成(注意,这里的多个线程是分属于不同进程的).操作系统不断的从一个线程的执行切换到另一个线程的执行,如此往复,宏观上看来,就好像是多个线程在一起执行.由于这多个线程分属于不同的进程,就好像是多个进程在同时执行,这样就实现了多任务。总线程数<=CPU数量时并行运行，总线程数>CPU数量时并发运行。并行运行的效率显然高于并发运行，所以在多CPU的计算机中，多任务的效率比较高。但是，如果在多CPU计算机中只运行一个进程(线程)，就不能发挥多CPU的优势。

2、说一下线程通信的方法、线程的五种状态？

线程通信的方法：

①同步：**多个线程通过synchronized关键字这种方式来实现线程间的通信**。

②while轮询的方式

③wait/notify机制

④管道通信就是使用java.io.PipedInputStream 和 java.io.PipedOutputStream进行通信

线程的五种状态：

![](img\线程.png)

- **新建(NEW)**：新创建了一个线程对象。
- **可运行(RUNNABLE)**：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu 的使用权 。
- **运行(RUNNING)**：可运行状态(runnable)的线程获得了cpu 时间片（timeslice） ，执行程序代码。
- **阻塞(BLOCKED)**：阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状态。阻塞的情况分三种：
  - 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。
  - 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。
  - 其他阻塞：运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。
- **死亡(DEAD)**：线程run()、main() 方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。

3、说一下线程的同步和互斥以及应用常见？

互斥：指**在某一时刻指允许一个进程运行其中的程序片，具有排他性和唯一性**。

对于线程A和线程B来讲，在同一时刻，只允许一个线程对临界资源进行操作，即当A进入临界区对资源操作时，B就必须等待；当A执行完，退出临界区后，B才能对临界资源进行操作。

同步：指的是**在互斥的基础上，实现进程之间的有序访问**。假设现有线程A和线程B，线程A需要往缓冲区写数据，线程B需要从缓冲区读数据，但他们之间存在一种制约关系，即当线程A写的时候，B不能来拿数据；B在拿数据的时候A不能往缓冲区写，也就是说，只有当A写完数据（或B取走数据），B才能来读数据（或A才能往里写数据）。这种关系就是一种线程的同步关系。

应用常见：多线程编程中，难免会遇到多个线程同时访问临界资源的问题，如果不对其加以保护，那么结果肯定是不如预期的，因此需要线程同步与互斥。

4、说一下进程和线程的区别？

进程：是具有一定独立功能的程序、它是系统进行资源分配和调度的一个独立单位，重点在**系统调度和单独的单位**，也就是说进程是可以独立运行的一段程序。

线程：是进程的一个实体，是CPU调度和分派的基本单位，比进程更小的能独立运行的基本单位，线程自己基本上不拥有系统资源，在运行时，只是暂用一些计数器、寄存器和栈 。线程有自己的堆栈和局部变量，但**线程之间没有单独的地址空间**。

一个程序至少有一个进程,一个进程至少有一个线程。

5、说一下死锁的概念、原因、解决方法？

死锁是指**在一组进程中的各个进程均占有不会释放的资源，但因互相申请被其他进程所站用不会释放的资源而处于的一种永久等待状态**。死锁的四个必要条件：

- 互斥条件(Mutual exclusion)：资源不能被共享，只能由一个进程使用。
- 请求与保持条件(Hold and wait)：已经得到资源的进程可以再次申请新的资源。
- 非剥夺条件(No pre-emption)：已经分配的资源不能从相应的进程中被强制地剥夺。
- 循环等待条件(Circular wait)：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源。

java中产生死锁可能性的最根本原因是：1）是多个线程涉及到多个锁，这些锁存在着交叉，所以可能会导致了一个锁依赖的闭环；2）默认的锁申请操作是阻塞的。

如，线程在获得一个锁L1的情况下再去申请另外一个锁L2，也就是锁L1想要包含了锁L2，在获得了锁L1，并且没有释放锁L1的情况下，又去申请获得锁L2，这个是产生死锁的最根本原因。

避免死锁：

- 破坏互斥条件：例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。 
- 破坏占有和等待条件：一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。 
- 破坏不可抢占条件。
- 破坏环路等待：给资源统一编号，进程只能按编号顺序来请求资源。 

6、说一下多线程？

如果有多个线程同时运行，而且它们试图访问相同的资源，就会遇到一个问题。举个例子来说，两个线程不能将信息同时发送给一台打印机。为解决这个问题，对那些可共享的资源来说(比如打印机)，它们在使用期间必须进入锁定状态。所以一个线程可将资源锁定，在完成了它的任务后，再解开(释放)这个锁，使其他线程可以接着使用同样的资源。

**多线程是为了同步完成多项任务**，不是为了提高运行效率，而是**为了提高资源使用效率来提高系统的效率**。线程是在同一时间需要完成多项任务的时候实现的。

一个采用了多线程技术的应用程序可以更好地利用系统资源。其主要优势在于充分利用了CPU的空闲时间片，可以用尽可能少的时间来对用户的要求做出响应，使得进程的整体运行效率得到较大提高，同时增强了应用程序的灵活性。更为重要的是，由于同一进程的所有线程是共享同一内存，所以不需要特殊的数据传送机制，不需要建立共享存储区或共享文件，从而使得不同任务之间的协调操作与运行、数据的交互、资源的分配等问题更加易于解决。

7、进程同步的方法？

- 临界区（Critical Section）:通过**对多线程的串行化来访问公共资源或一段代码**，速度快，适合控制数据访问。

  优点：保证在某一时刻只有一个线程能访问数据的简便办法

  缺点：虽然临界区同步速度很快，但却只能用来同步本进程内的线程，而不可用来同步多个进程中的线程。

- 互斥量（Mutex）:**为协调共同对一个共享资源的单独访问而设计的**。

  互斥量跟临界区很相似，比临界区复杂，互斥对象只有一个，只有拥有互斥对象的线程才具有访问资源的权限。

  优点：使用互斥不仅仅能够在同一应用程序不同线程中实现资源的安全共享，而且可以在不同应用程序的线程之间实现对资源的安全共享。

  缺点：①互斥量是可以命名的，也就是说它可以跨越进程使用，所以创建互斥量需要的资源更多，所以如果只为了在进程内部是用的话使用临界区会带来速度上的优势并能够减少资源占用量。因为互斥量是跨进程的互斥量一旦被创建，就可以通过名字打开它。

  ②通过互斥量可以指定资源被独占的方式使用，但如果有下面一种情况通过互斥量就无法处理，比如现在一位用户购买了一份三个并发访问许可的数据库系统，可以根据用户购买的访问许可数量来决定有多少个线程/进程能同时进行数据库操作，这时候如果利用互斥量就没有办法完成这个要求，信号量对象可以说是一种资源计数器。

- 信号量（Semaphore）:**为控制一个具有有限数量用户资源而设计**。它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。互斥量是信号量的一种特殊情况，当信号量的最大资源数=1就是互斥量了。

  优点：适用于对Socket（套接字）程序中线程的同步。（例如，网络上的HTTP服务器要对同一时间内访问同一页面的用户数加以限制，只有不大于设定的最大用户数目的线程能够进行访问，而其他的访问企图则被挂起，只有在有用户退出对此页面的访问后才有可能进入。）

  缺点：①信号量机制必须有公共内存，不能用于分布式操作系统，这是它最大的弱点；

  ②信号量机制功能强大，但使用时对信号量的操作分散， 而且难以控制，读写和维护都很困难，加重了程序员的编码负担；

  ③核心操作P-V分散在各用户程序的代码中，不易控制和管理，一旦错误，后果严重，且不易发现和纠正。

- 事件（Event）: **用来通知线程有一些事件已发生，从而启动后继任务的开始**。

  优点：事件对象通过通知操作的方式来保持线程的同步，并且可以实现不同进程中的线程同步操作。

8、进程线程的区别，进程间怎么相互通信，什么是多线程，什么是并发？

进程和线程的区别有以下几点：

- 拥有资源：**进程是资源分配的基本单位，但是线程不拥有资源**，线程可以访问隶属进程的资源。 
- 调度：**线程是独立调度的基本单位**，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。 
- 通信方面：**线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC**。 

进程间的通信方式：

- 管道：只支持半双工通信（单向交替传输）；**只能在父子进程或者兄弟进程中使用**。
- FIFO：也称为命名管道，**去除了管道只能在父子进程中使用的限制**。 
- 消息队列：**消息队列可以独立于读写进程存在**，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；**读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收**。
- 信号量：它是一个计数器，用于**为多个进程提供对共享数据对象的访问**。 
- 共享存储：允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。 需要**使用信号量用来同步对共享存储的访问**。多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用内存的匿名段。
- 套接字：与其它通信机制不同的是，它**可用于不同机器间的进程通信**。 

多线程就是指**一个进程中同时有多个执行路径正在执行**。

并发指在操作系统中，**一个时间段中有几个程序都已处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上面，但任意时刻点上只有一个程序在处理机上运行**。

9、并发？共享？虚拟？异步？

- 并发：并发是指**宏观上在一段时间内能同时运行多个程序**，而**并行则指同一时刻能运行多个指令**。并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。操作系统通过引入进程和线程，使得程序能够并发运行。
- 共享：共享是指**系统中的资源可以被多个并发进程共同使用**。有两种共享方式：互斥共享和同时共享。互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。
- 虚拟：虚拟技术**把一个物理实体转换为多个逻辑实体**。主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。
- 异步：异步指进程**不是一次性执行完毕，而是走走停停，以不可知的速度向前推进**。

10、 进程调度算法？

不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。 

批处理系统：**批处理系统没有太多的用户操作**，在该系统中，调度算法目标是**保证吞吐量和周转时间**（从提交到终止的时间）。 

- **先来先服务 first-come first-serverd（FCFS）**：非抢占式的调度算法，**按照请求的顺序进行调度**。 有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。 
- **短作业优先 shortest job first（SJF）** ：非抢占式的调度算法，**按估计运行时间最短的顺序进行调度**。长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。
- **最短剩余时间优先 shortest remaining time next（SRTN）** ：最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 **当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待**。 

交互式系统：**交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应**。 

- **时间片轮转** ：将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程 。
- **优先级调度** ：为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。
- **多级反馈队列** ：一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。

实时系统：实时系统要求一个请求在一个确定时间内得到响应。分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。

11、操作系统基本功能？

- 进程管理：进程控制、进程同步、进程通信、死锁处理、处理机调度等。 
- 内存管理：内存分配、地址映射、内存保护与共享、虚拟内存等。 
- 文件管理：文件存储空间的管理、目录管理、文件读写管理和保护等。 
- 设备管理：完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。主要包括缓冲管理、设备分配、设备处理、虛拟设备等。

12、页面置换算法？

- 最佳（OPT, Optimal replacement algorithm）：所选择的**被换出的页面将是最长时间内不再被访问**，通常可以保证获得最低的缺页率。是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。
- 最近最久未使用（LRU, Least Recently Used）：虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU **将最近最久未使用的页面换出**。 
- 最近未使用（NRU, Not Recently Used）：每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。
- 先进先出（FIFO, First In First Out）：选择换出的页面是最先进入的页面。该算法会**将那些经常被访问的页面也被换出，从而使缺页率升高**。
- 第二次机会算法：FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。
- 时钟（Clock）：第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。 

13、虚拟内存？

虚拟内存的目的是**为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。**

为了更好的管理内存，**操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页**。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。**当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。**

虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说**一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能**。例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。

14、磁盘调度算法？

读写一个磁盘块的时间的影响因素有： 

- 旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）
- 寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）
- 实际的数据传输时间

其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。

1）先来先服务（FCFS, First Come First Served）： **按照磁盘请求的顺序进行调度**。优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。

2）最短寻道时间优先（SSTF, Shortest Seek Time First）：**优先调度与当前磁头所在磁道距离最近的磁道**。虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象。

3）电梯算法（SCAN）：**电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。**

电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。**因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。**



## Linux

1、Ctrl+C：中断正在运行的程序；

2、VIM 三个模式：

- 一般指令模式（Command mode）：VIM 的默认模式，可以用于移动游标查看内容；
- 编辑模式（Insert mode）：按下 "i" 等按键之后进入，可以对文本进行编辑；
- 指令列模式（Bottom-line mode）：按下 ":" 按键之后进入，用于保存退出等操作。

![](img\vim.png)

在指令列模式下，有以下命令用于离开或者保存文件。 

![](img\vim0.PNG)

3、文件属性：用户分为三种，**文件拥有者、群组以及其它人**，对不同的用户有不同的文件权限。 

使用 ls 查看一个文件时，会显示一个文件的信息，例如 `drwxr-xr-x 3 root root 17 May 6 00:14 .config`，对这个信息的解释如下： 

- drwxr-xr-x：文件类型以及权限，第 1 位为文件类型字段，后 9 位为文件权限字段
- 3：链接数
- root：文件拥有者
- root：所属群组
- 17：文件大小
- May 6 00:14：文件最后被修改的时间
- .config：文件名

常见的文件类型及其含义有：

- d：目录
- -：文件
- l：链接文件

9 位的文件权限字段中，每 3 个为一组，共 3 组，每一组分别代表对文件拥有者、所属群组以及其它人的文件权限。一组权限中的 **3 位分别为 r、w、x 权限，表示可读、可写、可执行。**

4、文件与目录的基本操作：

- ls：列出文件或者目录的信息，目录的信息就是其中包含的文件。 
- mkdir：创建目录。 
- rmdir：删除目录，目录必须为空。 -p ：递归删除目录 
- touch：更新文件时间或者建立新文件。 
- cp：复制文件，cp [-adfilprsu] source destination 
- rm：删除文件，-r ：递归删除 
- mv：移动文件，mv [-fiu] source destination 

5、修改权限：可以将一组权限用数字来表示，此时一组权限的 3 个位当做二进制数字的位，从左到右每个位的权值为 4、2、1，即**每个权限对应的数字权值为 r : 4、w : 2、x : 1**。 

`chmod [-R] xyz dirname/filename` 

6、链接？

- 实体链接：在目录下创建一个条目，记录着文件名与 inode 编号，这个 inode 就是源文件的 inode。

  **删除任意一个条目，文件还是存在，只要引用数量不为 0**。有以下限制：**不能跨越文件系统、不能对目录进行链接。**

- 符号链接：**符号链接文件保存着源文件所在的绝对路径，在读取时会定位到源文件上，可以理解为 Windows 的快捷方式。当源文件被删除了，链接文件就打不开了。因为记录的是路径，所以可以为目录建立符号链接。**

7、获取文件内容：

- cat：取得文件内容 ，-n ：打印出行号，连同空白行也会有行号，-b 不会 
- tac：是 cat 的反向操作，从最后一行开始打印。 
- more：和 cat 不同的是它可以一页一页查看文件内容，比较适合大文件的查看。
- less：和 more 类似，但是多了一个向前翻页的功能。 
- head：取得文件前几行，-n ：后面接数字，代表显示几行的意思 。
- tail：是 head 的反向操作，只是取得是后几行。 

8、find：文件搜索，可以使用文件的属性和权限进行搜索。 

9、数据流重定向：重定向指的是使用文件代替标准输入、标准输出和标准错误输出。 

|           1           | 代码 |  运算符   |
| :-------------------: | :--: | :-------: |
|   标准输入 (stdin)    |  0   |  < 或 <<  |
|   标准输出 (stdout)   |  1   | >  或 >>  |
| 标准错误输出 (stderr) |  2   | 2> 或 2>> |

其中，**有一个箭头的表示以覆盖的方式重定向，而有两个箭头的表示以追加的方式重定向**。 

10、管道指令：管道是将一个命令的标准输出作为另一个命令的标准输入，在数据需要经过多个步骤的处理之后才能得到我们想要的内容时就可以使用管道**。在命令之间使用 | 分隔各个管道命令。

- 提取指令：cut 对数据进行切分，取出想要的部分。切分过程一行一行地进行。-d ：分隔符， -f ：经过 -d 分隔后，使用 -f n 取出第 n 个区间， -c ：以字符为单位取出区间 
- 排序指令：**sort** 用于排序。 
- **uniq** 可以将重复的数据只取一个。 

11、字符转换指令：**tr** 用来删除一行中的字符，或者对字符进行替换。 

12、正则表达式：g/re/p（globally search a regular expression and print)，使用正则表示式进行全局查找并打印。 

```linux
$ grep [-acinv] [--color=auto] 搜寻字符串 filename
-c ： 统计个数
-i ： 忽略大小写
-n ： 输出行号
-v ： 反向选择，也就是显示出没有 搜寻字符串 内容的那一行
--color=auto ：找到的关键字加颜色显示
```

因为 { 和 } 在 shell 是有特殊意义的，因此必须要使用转义字符进行转义。 

```linux
$ grep -n 'go\{2,5\}g' regular_express.txt
```

13、awk：awk 每次处理一行，处理的最小单位是字段，每个字段的命名方式为：`$ n，n 为字段号，从 1 开始，$0 表示一整行。` 

awk变量：

| 变量名称 |           代表意义           |
| :------: | :--------------------------: |
|    NF    |     每一行拥有的字段总数     |
|    NR    |   目前所处理的是第几行数据   |
|    FS    | 目前的分隔字符，默认是空格键 |

14、查看进程：

1）ps：查看某个时间点的进程信息。 

- 查看自己的进程 ：ps -l 
- 查看系统所有进程 ：ps aux 
- 查看特定的进程 ：ps aux | grep threadx 

2）top：实时显示进程信息。 top -d 2 ，两秒钟刷新一次 。

3）netstat：查看占用端口的进程 ，netstat -anp | grep port 

15、孤儿进程与僵尸进程？

- 孤儿进程：**一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程**。

  孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。

- 僵尸进程：一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait() 或 waitpid() 获取了子进程信息后才会释放。如果**子进程退出，而父进程并没有调用 wait() 或 waitpid()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程**。 



## 软件测试基础知识

1、介绍一下单元测试、集成测试、系统测试、验收测试、回归测试？

> - 单元测试：**完成最小的软件设计单元（模块）的验证工作**，目标是确保模块被正确的编码，使用过程设计描述作为指南，**对重要的控制路径进行测试以发现模块内的错误**，通常情况下是白盒的，对代码风格和规则、程序设计和结构、业务逻辑等进行静态测试，及早的发现和解决不易显现的错误。
>
> - 集成测试：**通过测试发现与模块接口有关的问题**。目标是把通过了单元测试的模块拿来，构造一个在设计中所描述的程序结构，应当避免一次性的集成（除非软件规模很小），而采用增量集成。
>
>   自顶向下集成：模块集成的顺序是首先集成主模块，然后按照控制层次结构向下进行集成，隶属于主模块的模块按照深度优先或广度优先的方式集成到整个结构中去。
>
>   自底向上集成：从原子模块开始来进行构造和测试，因为模块是自底向上集成的，进行时要求所有隶属于某个给顶层次的模块总是存在的，也不再有使用稳定测试桩的必要。
>
> - 系统测试：**是基于系统整体需求说明书的黑盒类测试，应覆盖系统所有联合的部件**。系统测试是针对整个产品系统进行的测试，目的是验证系统是否满足了需求规格的定义，找出与需求规格不相符合或与之矛盾的地方。系统测试的对象不仅仅包括需要测试的产品系统的软件，还要包含软件所依赖的硬件、外设甚至包括某些数据、某些支持软件及其接口等。因此，必须将系统中的软件与各种依赖的资源结合起来，在系统实际运行环境下来进行测试。
>
> - 回归测试**：回归测试是指在发生修改之后重新测试先前的测试用例以保证修改的正确性**。理论上，软件产生新版本，都需要进行回归测试，验证以前发现和修复的错误是否在新软件版本上再次出现。根据修复好了的缺陷再重新进行测试。回归测试的目的在于验证以前出现过但已经修复好的缺陷不再重新出现。一般指对某已知修正的缺陷再次围绕它原来出现时的步骤重新测试。
>
> - 验收测试：**验收测试是指系统开发生命周期方法论的一个阶段，这时相关的用户或独立测试人员根据测试计划和结果对系统进行测试和接收**。它让系统用户决定是否接收系统。它是一项确定产品是否能够满足合同或用户所规定需求的测试。验收测试包括Alpha测试和Beta测试。
>
>   Alpha测试：是由用户在开发者的场所来进行的，在一个受控的环境中进行。
>
>   Beta测试：由软件的最终用户在一个或多个用户场所来进行的，开发者通常不在现场，用户记录测试中遇到的问题并报告给开发者，开发者对系统进行最后的修改，并开始准备发布最终的软件。

2、说一说黑盒与白盒的测试方法？

1）黑盒测试： 

黑盒测试也称**功能测试或数据驱动测试**，它是在**已知产品所应具有的功能，通过测试来检测每个功能是否都能正常使用**，在测试时，把程序看作一个不能打开的黑盆子，在**完全不考虑程序内部结构和内部特性的情况下，测试者在程序接口进行测试，它只检查程序功能是否按照需求规格说明书的规定正常使用**，程序是否能适当地接收输入数锯而产生正确的输出信息，并且保持外部信息（如数据库或文件）的完整性。

“黑盒”法着眼于程序外部结构、不考虑内部逻辑结构、针对软件界面和软件功能进行测试。“黑盒”法是穷举输入测试，只有把所有可能的输入都作为测试情况使用，才能以这种方法查出程序中所有的错误。实际上测试情况有无穷多个，因此不仅要测试所有合法的输入，而且还要对那些不合法但是可能的输入进行测试。

常用的黑盒测试方法有：**等价类划分法；边界值分析法**；因果图法；场景法；正交实验设计法；判定表驱动分析法；错误推测法；功能图分析法。

> - 等价类划分是将系统的输入域划分为若干部分，然后从每个部分选取少量代表性数据进行测试。等价类可以划分为有效等价类和无效等价类，设计测试用例的时候要考虑这两种等价类。 
> - 边界值分析法是对等价类划分的一种补充，因为大多数错误都在输入输出的边界上。边界值分析就是假定大多数错误出现在输入条件的边界上，如果边界附件取值不会导致程序出错，那么其他取值出错的可能性也就很小。 

2）白盒测试： 

白盒测试也称为**结构测试或逻辑驱动测试**，是**针对被测单元内部是如何进行工作的测试**。它根据程序的控制结构设计测试用例，主要用于软件或程序验证。**白盒测试法检查程序内部逻辑结构，对所有的逻辑路径进行测试，是一种穷举路径的测试方法**，但即使每条路径都测试过了，但仍然有可能存在错误。因为：穷举路径测试无法检查出程序本身是否违反了设计规范，即程序是否是一个错误的程序；穷举路径测试不可能检查出程序因为遗漏路径而出错；穷举路径测试发现不了一些与数据相关的错误。

白盒测试需要遵循的原则有：1. 保证一个模块中的所有独立路径至少被测试一次；2. 所有逻辑值均需要测试真（true）和假（false）；两种情况；3. 检查程序的内部数据结构，保证其结构的有效性；4. 在上下边界及可操作范围内运行所有循环。

常用白盒测试方法：

静态测试：不用运行程序的测试，包括代码检查、静态结构分析、代码质量度量、文档测试等等，它可以由人工进行，充分发挥人的逻辑思维优势，也可以借助软件工具（Fxcop）自动进行。

动态测试：需要执行代码，通过运行程序找到问题，包括功能确认与接口测试、覆盖率分析、性能分析、内存分析等。 

白盒测试中的逻辑覆盖包括**语句覆盖、判定覆盖、条件覆盖、判定/条件覆盖、条件组合覆盖和路径覆盖。**

3、手动测试与自动化测试的优缺点？

手工测试：

> 缺点：
>
> - 重复的手工回归测试，代价昂贵、容易出错。
> - 依赖于软件测试人员的能力
>
> 优点：
>
> - 测试人员具有经验和对错误的猜测能力。
> - 测试人员具有审美能力和心理体验。
> - 测试人员具有是非判断和逻辑推理能力。

自动化测试：

> 缺点：
>
> - 不能取代手工测试
> - 手工测试比自动测试发现的缺陷更多
> - 对测试质量的依赖性极大
> - 测试自动化不能提高有效性
> - 测试自动化可能会制约软件开发。由于自动测试比手动测试更脆弱，所以维护会受到限制，从而制约软件的开发。
> - 工具本身并无想像力
>
> 优点：
>
> - **对程序的回归测试更方便。这可能是自动化测试最主要的任务**，特别是在程序修改比较频繁时，效果是非常明显的。由于回归测试的动作和用例是完全设计好的，测试期望的结果也是完全可以预料的，将回归测试自动运行，可以极大提高测试效率，缩短回归测试时间。
> - 可以运行更多更繁琐的测试。自动化的一个明显的好处是可以**在较少的时间内运行更多的测试。**
> - 可以执行一些手工测试困难或不可能进行的测试。比如，对于大量用户的测试，不可能同时让足够多的测试人员同时进行测试，但是却可以通过自动化测试模拟同时有许多用户，从而达到测试的目的。
> - 更好地利用资源。将繁琐的任务自动化，可以提高准确性和测试人员的积极性，将测试技术人员解脱出来投入更多精力设计更好的测试用例。有些测试不适合于自动测试，仅适合于手工测试，将可自动测试的测试自动化后，可以让测试人员专注于手工测试部分，提高手工测试的效率。
> - 测试具有一致性和可重复性。由于测试是自动执行的，每次测试的结果和执行的内容的一致性是可以得到保障的，从而达到测试的可重复的效果。
> - 测试的复用性。由于自动测试通常采用脚本技术，这样就有可能只需要做少量的甚至不做修改，实现在不同的测试过程中使用相同的用例。
> - 增加软件信任度。由于测试是自动执行的，所以不存在执行过程中的疏忽和错误，完全取决于测试的设计质量。一旦软件通过了强有力的自动测试后，软件的信任度自然会增加。

4、怎么看待软件测试的潜力和挑战？

软件测试是**正在快速发展，充满挑战的领域**。尽管现在许多自动化测试软件的出现使得传统手工测试的方式被代替，但自动化测试工具的开发、安全测试、测试建模、精准测试、性能测试、可靠性测试等专项测试中仍然**需要大量具有专业技能与专业素养的测试人员**，并且随着云计算、物联网、大数据的发展，传统的测试技术可能不再适用，测试人员也因此面临着挑战，需要深入了解新场景并针对不同场景尝试新的测试方法，同时敏捷测试、Devops的出现也显示了软件测试的潜力。 

5、软件测试的核心竞争力是什么？

测试人员的核心竞争力在于**提早发现问题，并能够发现别人无法发现的问题**。

- 早发现问题：问题发现的越早，解决的成本越低。如果一个需求在还未实现的时候就能发现需求的漏洞，那么这种问题的价值是最高的。
- 发现别人无法发现的问题：所有人都能发现的问题，你发现了，那就证明你是可以被替代的。别人发现不了，而你可以发现，那么你就是无法被替代。

6、如何写测试用例？

> - 测试人员尽早介入，彻底理解清楚需求，这个是写好测试用例的基础
> - 如果以前有类似的需求，可以参考类似需求的测试用例，然后还需要看类似需求的bug情况
> - 清楚输入、输出的各种可能性，以及各种输入的之间的关联关系，理解清楚需求的执行逻辑，通过等价类、边界值、判定表等方法找出大部分用例
> - 找到需求相关的一些特性，补充测试用例
> - 根据自己的经验分析遗漏的测试场景
> - 多总结类似功能点的测试点，才能够写出质量越来越高的测试用例
> - 书写格式一定要清晰

7、测试项目具体工作是什么？

> 搭建测试环境
>
> 撰写测试用例
>
> 执行测试用例
>
> 写测试计划，测试报告
>
> 测试，并提交BUG表单
>
> 跟踪bug修改情况
>
> 执行自动化测试，编写脚本，执行，分析，报告
>
> 进行性能测试，压力测试等其他测试，执行，分析，调优，报告

8、app性能测试的指标？

> - 内存：内存消耗测试节点的设计目标是为了让应用不占用过多的系统资源，且及时释放内存，保障整个系统的稳定性。当然关于内存测试，在这里我们需要引入几个概念：空闲状态、中等规格、满规格。
>
>   空闲状态指打开应用后，点击home键让应用后台运行，此时应用处于的状态叫做空闲；中等规格和满规格指的是对应用的操作时间的间隔长短不一，中等规格时间较长，满规格时间较短。
>
> - CPU 
>
> - 流量： 网络流量测试是针对大部分应用而言的，可能还有部分应用会关注网速、弱网之类的测试。 
>
> - 电量
>
> - 启动速度
>
> - 滑动速度、界面切换速度 
>
> - 与服务器交互的网络速度 

9、自动化测试框架？

> - 模块化测试框架：需要创建小而独立的可以描述的模块、片断以及待测应用程序的脚本 。
> - 测试库框架 ：与模块化测试脚本框架很类似，不同的是测试库框架把待测应用程序分解为过程和函数而不是脚本。这个框架需要创建描述模块、片断以及待测应用程序的功能库文件。 
> - 关键字驱动或表驱动的测试框架 ：对于一个独立于应用的自动化框架，关键字驱动（KEYWORD DRIVEN）I9LJJ试和表驱动（TABLE DRIVEN）测试是可以互换的术语。这个框架需要开发数据表和关键字。这些数据表和关键字独立于执行它们的测试自动化工具，并可以用来“驱动＂待测应用程序和数据的测试脚本代码，关键宇驱动测试看上去与手工测试用例很类似。在一个关键字驱动测试中，把待测应用程序的功能和每个测试的执行步骤一起写到一个表中。这个测试框架可以通过很少的代码来产生大量的测试用例。同样的代码在用数据表来产生各个测试用例的同时被复用。 
> - 数据驱动测试框架 ：测试的输入和输出数据是从数据文件中读取（数据池，ODBC源，CSV文件，EXCEL文件，ADO对象等）并且通过捕获工具生成或者手工生成的代码脚本被载入到变量中。在这个框架中，变量不仅被用来存放输入值还被用来存放输出的验证值。整个程序中，测试脚本来读取数值文件，记载测试状态和信息。这类似于表驱动测试，在表驱动测试中，它的测试用例是包含在数据文件而不是在脚本中，对于数据而言，脚本仅仅是一个“驱动器”，或者是一个传送机构。然而，数据驱动测试不同于表驱动测试，尽管导航数据并不包含在表结构中。在数据驱动测试中，数据文件中只包含测试数据。这个框架意图减少需要执行所有测试用例所需要的总的测试脚本数。数据驱动需要很少的代码来产生大量的测试用例，这与表驱动极其类似。 

10、怎么看待测试，知道哪些测试的类型？

**测试是软件开发中不可或缺的一环，测试通过经济，高效的方法，捕捉软件中的错误，从而达到保重软件内在质量的目的。**

测试分为功能测试和非功能测试，非功能测试又可以分为性能测试、压力测试、容量测试、健壮性测试、安全性测试、可靠性测试、恢复性测试、备份测试、协议测试、兼容性测试、可用性测试、配置测试、GUI测试。



## 软件测试实例

1、说一说**简单用户界面登录过程**都需要做哪些分析？ 

![](img\ts2.png)

2、对朋友圈点赞功能进行测试？ 

- 功能测试：点赞某条朋友圈，验证是否成功；
- 接口测试：点赞朋友圈，验证朋友能否收到提示信息；
- 性能测试：点赞朋友圈，是否在规定时间显示结果，是否在规定时间在朋友手机上进行提示；
- 兼容性测试：在不同的终端比如ipad,手机上点赞朋友圈，验证是否成功。

> - 是否可以正常点赞和取消；
> - 点赞的人是否在可见分组里；
> - 点赞状态是否能即时更新显示；
> - 点赞状态，共同好友是否可见；
> - 性能检测，网速快慢对其影响；
> - 点赞显示的是否正确，一行几个；
> - 点赞是否按时间进行排序，头像对应的是否正确；
> - 是否能在消息列表中显示点赞人的昵称；
> - 不同手机，系统显示界面如何；
> - 可扩展性测试，点赞后是否能发表评论；
> - 是否在未登录时可查看被点赞的信息。

3、如果做一个杯子的检测，如何测试？ 

![](img\ts3.png)

4、如何对一个页面进行测试？ 

> - **UI测试**：页面布局、页面样式检查、控件长度是否够长；显示时，是否会被截断；支持的快捷键，Tab键切换焦点顺序正确性等；
> - **功能测试**：页面上各类控件的测试范围，测试点。结合控件的实际作用来补充检查点： 比如， 密码框是否*显示， 输入是否做trim处理等；
> - **安全测试**：输入特殊字符，sql注入，脚本注入测试。后台验证测试，对于较重要的表单 ，绕过js检验后台是否验证；数据传输是否加密处理，比如， 直接请求转发，地址栏直接显示发送字符串；
> - **兼容性测试**；
> - **性能测试**。

5、如何对淘宝搜索框进行测试？ 

![](img\ts4.png)

6、如何对一瓶矿泉水进行测试？ 

> - 界面测试:查看外观是否美观；
> - 功能：查看水瓶漏不漏；瓶中水能不能被喝到；
> - 安全性：瓶子的材质有没有毒或细菌；
> - 可靠性：从不同高度落下的损坏程度；
> - 可移植性：再不同的地方、温度等环境下是否都可以正常使用；
> - 兼容性：是否能够容纳果汁、白水、酒精、汽油等；
> - 易用性：是否烫手、是否有防滑措施、是否方便饮用；
> - 用户文档：使用手册是否对的用法、限制、使用条件等有详细描述；
> - 疲劳测试：将盛上水（案例一）放24小时检查泄漏时间和情况；盛上汽油（案例二）放24小时检查泄漏时间和情况等；
> - 压力测试：用根针并在针上面不断加重量，看压强多大时会穿透；
> - 跌落测试:测试在何种高度跌落会破坏水瓶。

7、请说一下购物车的测试用例？

![](img\ts5.png)

8、请问web测试如何写的？ 

> - **功能测试**，主要做**链接测试，表单测试，cookies测试，设计语言测试**等；
> - **性能测试**，考虑**连接速度测试，以及负载测试**，例如：Web应用系统能允许多少个用户同时在线？如果超过了这个数量，会出现什么现象？Web应用系统能否处理大量用户对同一个页面的请求？还有压力测试；
> - **可用性测试**，比如**导航测试，图形测试，内容测试，整体界面测试**等；
> - **兼容性测试**，市场上有很多不同的操作系统类型，最常见的有**Windows、Unix、Macintosh、Linux等**。Web应用系统的最终用户究竟使用哪一种操作系统，取决于用户系统的配置。这样，就可能会发生兼容性问题，同一个应用可能在某些操作系统下能正常运行，但在另外的操作系统下可能会运行失败。因此，在Web系统发布之前，需要在各种操作系统下对Web系统进行兼容性测试；
> - **安全性测试**；

9、如何测试手机开机键？ 

> - **功能测试**：按下开机键，屏幕能否亮起；
> - **性能测试**：按下开机键，屏幕能否在规定时间内亮起；
> - **压力测试**：连续多次按下开机键，观察屏幕是否能一直亮起，到多久时间失灵；
> - **健壮性测试**：给定一个中了病毒的手机或者是淘汰许久的老机子，安歇开机键观察屏幕能否亮起；
> - **可靠性测试**：连续按下开机键有限次数，比如1万次，记录屏幕未亮起的次数；
> - **可用性测试**：开机键按下费不费力，开机键的形状设计是否贴合手指，开机键的位置设计是否方便。

10、接口测试出现bug的原因有哪些？ 

> - **特殊值处理不当**导致程序异常退出或者崩溃；
> - 类型**边界溢出**，导致数据独处和写入不一致；
> - 取值**边界外未返回正确的错误信息**；
> - **权限未处理**，可以访问其他用户的信息；
> - **逻辑校验不完善**，可以利用漏洞获取非正当利益；
> - **状态处理不当**，导致逻辑出现错误；
> - 数组类型item个数为0或者item重复时程序异常退出。

11、在做测试的过程中，假如前端和后端吵起来了都在踢皮球觉得对方该改代码，你怎么办？

此时就应该找技术领导拍板或leader们基于安全性、性能、可测试性、可维护性讨论敲定一个解决方案，做到开发环境方便开发，线上环境少配置、少依赖、少出错机会。



## Java

### Java基础

1、多态？

多态就是指**程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定**，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，**不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变**，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让**程序可以选择多个运行状态**，这就是多态性。 

Java实现多态有三个必要条件：继承、重写、向上转型。 

- 继承：在多态中必须存在有继承关系的子类和父类。
- 重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。
- 向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。

Java中有两种形式可以实现多态，**继承、接口**： 

- 基于继承的实现机制主要表现在**父类和继承该父类的一个或多个子类对某些方法的重写，多个子类对同一方法的重写可以表现出不同的行为。**
- 基于接口的多态中，指向接口的引用必须是指定这实现了该接口的一个类的实例程序，**在运行时，根据对象引用的实际类型来执行对应的方法**。

2、重写、重载？

- 重写指的是**在Java的子类与父类中有两个名称、参数列表都相同的方法的情况**。由于他们具有相同的方法签名，所以**子类中的新方法将覆盖父类中原有的方法**。
- 简单说，就是**方法有同样的名称，但是参数列表不相同的情形**，这样的同名不同参数的方法之间，互相称之为重载方法。 应该注意的是，返回值不同，其它都相同不算是重载。 

区别：位置不一样 ，一个是说父子类，一个是当前类中；方法参数变化，一个不变化，一个是参数个数可以不一样。

> 1、重载是一个**编译期**概念、重写是一个**运行期间**概念。
>
> 2、重载遵循所谓“编译期绑定”，即在编译时根据参数变量的类型判断应该调用哪个方法。
>
> 3、重写遵循所谓“运行期绑定”，即在运行的时候，根据引用变量所指向的实际对象的类型来调用方法。
>
> 4、因为在编译期已经确定调用哪个方法，所以重载并不是多态。而重写是多态。重载只是一种语言特性，是一种语法规则，与多态无关，与面向对象也无关。（注：严格来说，**重载是编译时多态**，即静态多态。但是，Java中提到的多态，在不特别说明的情况下都指动态多态）

3、Java中接口与抽象类区别？

- 抽象类是用来**捕捉子类的通用特性**的。它不能被实例化，只能被用作子类的超类。抽象类是被用来创建继承层级里子类的模板。
- **接口是抽象方法的集合**。如果一个类实现了某个接口，那么它就继承了这个接口的抽象方法。

区别：

> 从语法层面来说：
>
> - 抽象类可以提供成员方法的实现细节，而接口中只能存在抽象方法
> - 抽象类中成员变量可以是多种类型，接口中成员变量必须用public，static，final修饰
> - 一个类只能继承一个抽象类，但可以实现多个接口
> - 抽象类中允许含有静态代码块和静态方法，接口不能
>
> 从设计层面而言：
>
> - 抽象类是对整一个类的属性，行为等方面进行抽象，而接口则是对行为抽象。就好比飞机和鸟，抽象类抽象出的是飞行物类。而接口则是抽闲出飞行方法。 
> - 抽象类是一个模板式的设计，当在开发过程中出现需求更改的情况，只需要更改抽象类而不需要更改它的子类。接口是一种辐射性设计，当接口的内容发生改变时，需要同时对实现它的子类进行相应的修改。 
> - 抽象类可以类比为模板，而接口可以类比为协议。

什么时候使用抽象类和接口：

- 如果拥有一些方法并且想让它们中的一些有默认实现，使用抽象类。
- 如果想实现多重继承，必须使用接口。由于Java不支持多继承，子类不能够继承多个类，但可以实现多个接口。
- 如果基本功能在不断改变，那么就需要使用抽象类。如果不断改变基本功能并且使用接口，那么就需要改变所有实现了该接口的类。

4、java jvm的内存机制？垃圾回收机制？

Java内存区域划分：

![](img\jvm.PNG)

- 程序计数器：可以看做是**当前线程所执行的字节码的行号指示器**。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。 （线程私有的内存区域）
- Java虚拟机栈：描述**Java方法执行的内存模型，每个方法执行的同时会创建一个栈帧**，栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 （线程私有的）
- 本地方法栈：本地方法栈与虚拟机栈的区别：虚拟机栈为虚拟机执行Java方法服务（也就是字节码），而**本地方法栈为虚拟机使用到的Native方法服务**。 
- Java堆：Java**堆是被所有的线程共享的一块内存区域**，在虚拟机启动时创建。Java堆的唯一目的就是**存放对象实例**，几乎所有的对象实例都在这里分配内存。 
- 方法区：**被所有的线程共享的一块内存区域**。它**用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据**。 

内存泄漏与内存溢出？

- 内存泄漏（memory leak） ：是指**程序在申请内存后，无法释放已申请的内存空间**，一次内存泄漏似乎不会有大的影响，但内存泄漏堆积后的后果就是内存溢出。 

  > 常见的内存泄漏： 
  >
  > - 单例造成内存泄漏：由于单例的静态特性使得其生命周期和应用的生命周期一样长，如果一个对象已经不再需要使用了，而单例对象还持有该对象的引用，就会使得该对象不能被正常回收，从而导致了内存泄漏。 
  > - 资源未关闭造成的内存泄漏：对于使用了File，Stream等资源，应该在Activity销毁时及时关闭或者注销，否则这些资源将不会被回收，从而造成内存泄漏。 

- 内存溢出 （out of memory） ：指**程序申请内存时，没有足够的内存供申请者使用**，或者说，给了你一块存储int类型数据的存储空间，但是你却存储long类型的数据，那么结果就是内存不够用，此时就会报错OOM，即所谓的内存溢出。  

垃圾回收(Garbage Collection)是**Java虚拟机(JVM)垃圾回收器提供的一种用于在空闲时间不定时回收无任何对象引用的对象占据的内存空间的一种机制**。

引用：如果Reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。

> （1）强引用（Strong Reference）：在 Java中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到 JVM 也不会回收。因此强引用是造成 Java 内存泄漏的主要原因之一。只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象。
>
> （2）软引用（Soft Reference）：软引用需要用 SoftReference 类来实现，对于只有软引用的对象来说，当系统内存足够时它不会被回收，当系统内存空间不足时它会被回收。软引用通常用在对内存敏感的程序中。
>
> （3）弱引用（Weak Reference）：弱引用需要用 WeakReference 类来实现，它比软引用的生存期更短，对于只有弱引用的对象 来说，只要垃圾回收机制一运行，不管 JVM 的内存空间是否足够，总会回收该对象占用的内存。
>
> （4）虚引用（Phantom Reference）：虚引用需要 PhantomReference 类来实现，它不能单独使用，必须和引用队列联合使用。 虚引用的主要作用是跟踪对象被垃圾回收的状态。    

垃圾：无任何对象引用的对象。 

判断对象是否是垃圾的算法： 

- 引用计数算法（Reference Counting Collector）：**给对象添加一个引用计数器，每当有一个地方引用他时，计数器就加一，引用失败计数器减一**，计数器为零的对象就不可能再被使用。
- 根搜索算法（Tracing Collector）：通过一系列的称为"GC Roots"的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为引用链。**当一个对象到GC Roots没有任何引用链相连的时候，则证明此对象是不可用的**。否则即是可达的。

GC Root可以是：虚拟机栈（栈帧中的本地变量表）中引用的对象；本地方法栈中JNI（即一般说的native方法）引用的对象；方法区中的静态变量和常量引用的对象。 

回收：清理“垃圾”占用的内存空间而非对象本身。

**标记—清除算法**：分为“标记”和“清除”两个阶段：首先**标记出所需回收的对象，在标记完成后统一回收掉所有被标记的对象**，算法最大的问题是**内存碎片化严重** 。

**标记—整理算法**：标记的过程与标记—清除算法中的标记过程一样，但**对标记后出的垃圾对象的处理情况有所不同，它不是直接对可回收对象进行清理，而是让所有的对象都向一端移动，然后直接清理掉端边界以外的内存**。

**复制算法**（Copying Collector）：**将内存按容量分为大小相等的两块，每次只使用其中的一块（对象面），当这一块的内存用完了，就将还存活着的对象复制到另外一块内存上面（空闲面），然后再把已使用过的内存空间一次清理掉**。可用内存被压缩到了原本的一半。且存活对象增多的话， Copying 算法的效率会大大降低。    

发生地点：**一般发生在堆内存中，因为大部分的对象都储存在堆内存中**。

分代收集算法：    

Java的堆内存基于Generation算法（Generational Collector）划分为**新生代、年老代和持久代**。新生代又被进一步划分为Eden和Survivor区，最后Survivor由FromSpace（Survivor0）和ToSpace（Survivor1）组成。所有通过new创建的对象的内存都在堆中分配。分代收集基于这样一个事实：**不同的对象的生命周期是不一样的。因此，可以将不同生命周期的对象分代，不同的代采取不同的回收算法进行垃圾回收（GC）**，以便提高回收效率。 

- 新生代与复制算法：目前大部分 JVM 的 GC **对于新生代都采取 Copying 算法**，因为**新生代中每次垃圾回收都要回收大部分对象，即要复制的操作比较少**，但通常并不是按照 1： 1 来划分新生代。一般将新生代 划分为一块较大的 Eden 空间和两个较小的 Survivor 空间(From Space, To Space)，每次使用 Eden 空间和其中的一块 Survivor 空间，当进行回收时，将该两块空间中还存活的对象复制到另 一块 Survivor 空间中。    
- 老年代与标记整理算法：**老年代因为每次只回收少量对象，因而采用标记-整理算法**。

5、String、StringBuffer and StringBuilder？

线程安全性：**线程安全 String 、StringBuffer（**内部使用 synchronized 进行同步 **）；非线程安全 StringBuilder**。

执行效率： StringBuilder > StringBuffer > String 

存储空间：**String 的值是不可变的**，每次对String的操作都会生成新的String对象，效率低耗费大量内存空间，从而引起GC。**StringBuffer和StringBuilder都是可变**。

使用场景：如果要操作少量的数据用 String ；单线程操作字符串缓冲区下操作大量数据 = StringBuilder ；多线程操作字符串缓冲区下操作大量数据 = StringBuffer。

6、Object 通用方法？

- equals()：对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。
- hashCode()：hashCode() 返回散列值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价。 
- toString()：默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。 
- clone()：是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。 **浅拷贝**：拷贝对象和原始对象的引用类型引用同一个对象。**深拷贝**：拷贝对象和原始对象的引用类型引用不同对象。 

7、对象比较为什么要重写hashcode 和 equals ？

hashcode：计算键的hashcode作为存储键信息的**数组下标用于查找键对象的存储位置**。equals：HashMap使用equals()判断**当前的键是否与表中存在的键相同**。 

8、Java中的异常处理机制？

Throwable 可以用来表示任何可以作为异常抛出的类，分为两种： **Error** 和 **Exception**。其中 Error 用来表示 JVM 无法处理的错误，Exception 分为两种： 

- **受检异常** ：需要用 try...catch... 语句捕获并进行处理，并且可以从异常中恢复 ；
- **非受检异常** ：是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复。

9、反射？

JAVA反射机制是**在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性**；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。Java反射可以**用来获取一个class对象或实例化一个class表示的类的对象，还可以获取构造方法，成员变量，成员方法**。 

反射的优点缺点： 

- 优点：**可扩展性** ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。**类浏览器和可视化开发环境** ：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。**调试器和测试工具** ： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率。
- 缺点：**性能瓶颈**：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的java代码要慢很多；**安全限制** ；**内部暴露**。

反射的应用： 

- JDBC 的数据库的连接：通过Class.forName()加载数据库的驱动程序 （通过反射加载，前提是引入相关了Jar包）； 
- Spring 框架的使用：Spring 通过 XML 配置模式装载 Bean 的过程；

10、泛型？

Java泛型 `generics` 允许在定义类和接口的时候使用类型参数（type parameter）。**声明的类型参数在使用时用具体的类型来替换**。从好的方面来说，泛型的引入可以解决之前的集合类框架在使用过程中通常会出现的运行时刻类型错误，因为编译器可以在编译时刻就发现很多明显的错误。而从不好的地方来说，为了保证与旧有版本的兼容性，Java泛型的实现上存在着一些不够优雅的地方。**泛型使编译器可以在编译期间对类型进行检查以提高类型安全，减少运行时由于对象类型不匹配引发的异常。** 

**类型擦除**（type erasure ）：Java中的泛型基本上都是在编译器这个层次来实现的。在生成的Java字节代码中是不包含泛型中的类型信息的。**使用泛型的时候加上的类型参数，会被编译器在编译的时候去掉**。这个过程就称为类型擦除。如在代码中定义的`List<Object>` 和`List<String>`等类型，在编译之后都会变成List。JVM看到的只是List，而由泛型附加的类型信息对JVM来说是不可见的。Java编译器会在编译时尽可能的发现可能出错的地方，但是仍然无法避免在运行时刻出现类型转换异常的情况。

11、Java与C++的区别？

- Java 是**纯粹的面向对象语言，所有的对象都继承自 java.lang.Object**，C++ 为了兼容 C 即支持面向对象也支持面向过程。
- Java **通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台**。
- Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。
- Java **支持自动垃圾回收**，而 C++ 需要手动回收。
- Java **不支持多重继承，只能通过实现多个接口来达到相同目的**，而 C++ 支持多重继承。

12、类加载？

类的加载指的是**将类的.class文件中的二进制数据读入到内存中**，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。

类加载分为五个部分：加载，验证，准备，解析，初始化。

> - 加载：会在内存中生成一个代表这个类的 java.lang.Class 对 象， 作为方法区这个类的各种数据的入口。    
> - 验证：为了确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。
> - 准备：正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。    
> - 解析：指虚拟机将常量池中的符号引用替换为直接引用的过程。
> - 初始化：是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载 器以外，其它操作都由 JVM 主导。到了初始阶段，才开始真正执行类中定义的 Java 程序代码。    

类加载有三种方式： 

- 命令行启动应用时候由JVM初始化加载；
- 通过Class.forName()方法动态加载；
- 通过ClassLoader.loadClass()方法动态加载。

双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是**把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中**，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。 好处：**使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系**，从而使得基础类得到统一。 

13、包装类？装箱拆箱？

Java语言是一个面向对象的语言,但**Java中的基本数据类型却是不面向对象的**. 这在实际使用时存在很多的不便。为了解决这个不足(例如:集合类中只能存放对象, 不能存放基本类型数据), 在设计类时为每个基本数据类型设计了一个对应的类进行代表, 这样八个和基本数据类型对应的类统称为包装类(Wrapper Class)。包装类：作为和基本数据类型对应的类类型存在，方便涉及到对象的操作。

为什么需要包装类：因为**Java是一种面向对象语言，很多地方都需要使用对象而不是基本数据类型**。比如，在集合类中，我们是无法将int 、double等类型放进去的。因为集合的容器要求元素是Object类型。**为了让基本类型也具有对象的特征，就出现了包装类型**，它相当于将基本类型“包装起来”，使得它具有了对象的性质，并且为其添加了属性和方法，丰富了基本类型的操作。  

拆箱与装箱：

- 装箱：把**基本数据类型转换成包装类**的过程就是打包装；
- 拆箱：把**包装类转换成基本数据类型**的过程就是拆包装；

14、protected，public，private的区别？

![](img\访问修饰符.PNG)

15、Java内存模型三大特性？

- 原子性：

- 可见性：可见性指**当一个线程修改了共享变量的值，其它线程能够立即得知这个修改**。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。 

  > 主要有三种实现可见性的方式： 
  >
  > - volatile
  > - synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。
  > - final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。

- 有序性：有序性是指：在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，**无序是因为发生了指令重排序。在 Java 内存模型中，允许编译器和处理器对指令进行重排序**，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。 

16、为什么Java被称作是“平台无关的编程语言”？

**Java虚拟机是一个可以执行Java字节码的虚拟机进程**。Java源文件被编译成能被Java虚拟机执行的字节码文件。  Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。**Java虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性**。 

### Java集合框架

![](img\集合框架.PNG)

1、List：一个**有序的**Collection（也称序列），**以元素的添加的顺序作为集合的顺序** ，**元素可以重复**。列表通常允许满足e1.equals(e2)的元素对e1和e2，并且列表**允许多个null元素**。 

- ArrayList：**允许重复，允许放入null元素；以数组实现；非线程安全；默认第一次插入元素时创建数组的大小为10，超出限制会增加50%的容量**。
- Vector，实现与 ArrayList 类似，但是**使用了 synchronized 进行同步**。扩容时每次都令 capacity 为原来的两倍。  
- LinkedList：**允许重复；以双向链表实现；非线程安全**；同时实现了list接口和Deque接口。

2、Set：内部用一个Map来实现。

- HashSet：基于HashMap实现；**不允许重复，允许null；非线程安全**。
- LinkedHashSet：基于LinkedHashMap实现；**允许null值；保留插入顺序；非线程安全**。
- TreeSet：对TreeMap简单包装；**不允许重复，不允许null值；默认按升序排列；非线程安全**。

3、Map：

1）HashMap：**允许键、值为null；基于数组+链表实现；非线程安全**。在HashMap**进行扩容重哈希时导致Entry链形成环。一旦Entry链中有环，会导致在同一个桶中进行插入、查询、删除等操作时陷入死循环。**

- 内部存储结构：数组+链表+红黑树（JDK8） ;
- 默认容量16，默认装载因子0.75；
- key和value对数据类型的要求都是泛型；
- key可以为null，放在table[0]中；
- hashcode：计算键的hashcode作为存储键信息的数组下标用于查找键对象的存储位置。equals：HashMap使用equals()判断当前的键是否与表中存在的键相同。 

![](img\hashmap.PNG)

![](img\hashmap-.PNG)

> - put：将指定的键、值对添加到map里，根据key值计算出hashcode，根据hashcode定位出所在桶。如果桶是一个链表则需要遍历判断里面的hashcode、key值是否和传入key相等，如果相等则进行覆盖，否则插入（头插法）新的Entry。如果桶是空的，说明当前位置没有数据存入，新增一个Entry对象写入当前位置。
> - get：根据指定的key值返回对应的value，根据key计算出hashcode，定位到桶的下标，如果桶是一个链表，依次遍历冲突链表，通过key.equals（k）方法来判断是否是要找的那个entry。如果桶不是链表，根据key是否相等返回值。

注：当hash冲突严重时，**在桶上形成的链表会变的越来越长，这样在查询时的效率就会越来越低。JDK1.8的优化：数组+链表/红黑树。判断当前链表的大小是否大于预设的阈值，大于时就要转换为红黑树。**

2）HashTable：**HashTable是线程安全；键、值均不可为nul**l，其余与HashMap大致相同。

**HashTable容器使用Synchronized来保证线程安全**，但在线程竞争激烈的情况下，HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法时，其他线程访问HashTable的同步方法时，**可能会进入阻塞或轮询状态**。

3）LinkedHashMap：**允许键/值为null；非线程安全**；在HashMap的基础上，采用双向链表的形式将所有entry连接起来，为**保证元素的迭代顺序跟插入顺序相同**。

> put：
>
> - 从table的角度看，新的entry需要插入到对应的桶里，当有哈希冲突时，采用头插法将新的entry插入到冲突链表的头部。
> - 从header的角度看，新的entry需要插入到双向链表的尾部。
>
> remove：
>
> - 从table的角度看，需要将该entry从对应的桶里删除，如果对应的冲突链表不空，需要修改冲突链表的相应引用。
> - 从heder角度看，需要将该entry从双向链表中删除，同时修改链表中前面以及后面元素的相应引用。

4）TreeMap：**键、值均不可为null；线程非安全；底层通过红黑树实现**；实现了SortdMap接口，会按key的大小顺序对Map中的元素进行排序，key的大小可以通过其本身的自然顺序，也可以通过构造时传入的比较器。

**红黑树是一种近似平衡的二叉查找树**，能确保任何一个结点的左右子树的高度差不会超过二者中较低的那个的一倍。

红黑树特征：

- 每个结点要么是红色，要么是黑色；
- 根节点永远是黑色；
- 所有的叶结点都是黑色的；
- 每个红色结点的两个子节点一定都是黑色；
- 从任一结点到其子树中每个叶子结点的路径都包含相同数量黑色结点。

调整：

1）颜色调整：

2）结构调整：左旋（Rotate left）、右旋（Rotate right）

```java
 //   node                     x
    //  /   \     左旋转         /  \
    // T1   x   --------->   node   T3
    //     / \              /   \
    //    T2 T3            T1   T2
private Node leftRotate(Node node){
    Node x = node.right;

    // 左旋转
    node.right = x.left;
    x.left = node;

    x.color = node.color;
    node.color = RED;

    return x;
}
//     node                   x
    //    /   \     右旋转       /  \
    //   x    T2   ------->   y   node
    //  / \                       /  \
    // y  T1                     T1  T2
private Node rightRotate(Node node) {
    Node x = node.left;
    //右旋转
    node.left = x.right;
    x.right = node;

    x.color = node.color;
    node.color = RED;

    return x;
}
```

remove：待删除结点左右子树均不为空，1）找到比待删除结点大的最小结点，即待删除结点右子树的最小结点；2）用这个结点顶替待删除结点的位置。

5）ConCurrentHashMap：**不允许键、值为null；使用锁分段技术**（容器有多把锁，每一把锁用于锁容器其中一部分数据）。由segment数组结构和HashEntry数组结构组成。**segment是一种可重入锁Reentantlock，在concurrentHashMap里扮演锁的角色。HashEntry则用于存储键值对数据**。

为了能通过按位与的哈希算法来定位 segments 数组的索引，必须保证 segments 数组的长度是 2 的 N 次方 。

一个ConcurrentHashMap里包含一个**segment数组，segment的结构和HashMap类似，是一种数组和链表结构**，一个segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素。

![](img\currentHashMap.PNG)

> 定位segment：
>
> concurrentHashMap使用分段锁segment来保护不同段的数据，那么**在插入和获取元素的时候，必须先通过哈希算法定位到segment**。
>
> get：
>
> - 先经过一次再哈希，然后使用这个哈希值通过哈希运算定位到segment，再通过哈希算法定位到元素。
> - get操作的高效之处在于**整个get过程不需要加锁，除非读到的值是空的才会加锁重读**。它的get方法里**将要使用的共享变量都定义成Volatile**，如用于统计当前segment大小的count字段和用于存储值的HashEntry的value。**定义成Volatile的变量，能够在线程之间保持可见性，能够被多线程同时读，并且保证不会读到过期的值**。但是只能被单线程写（有一种情况可以被多线程写，就是写入的值不依赖于原值），之所以不会读到过期的值，是根据**java内存模型的happen-before原则，对volatile字段的写入操作先于读操作**，即使两个线程同时修改和获取volatile变量，get操作也能拿到最新的值。（将key通过Hash之后定位到具体的segment，再通过一次Hash定位到具体的元素上）。
>
> put：
>
> 需要对共享变量进行写入操作，所以**为了线程安全，在操作共享变量时必须得加锁。put方法首先定位到segment，然后再segment里进行插入操作。**
>
> - 判断是否需要对segment里的HashEntry数组进行扩容；
> - 定位添加元素的位置，然后放在HashEntry数组里。
>
> segment的扩容判断比HashMap更恰当：**HashMap是在插入元素后判断元素是否已经到达容量的，如果到达了就进行扩容，但是很有可能扩容之后就没有新元素插入，这时HashMap就进行了一次无效的扩容**。ConcurrentHashMap**扩容的时候首先会创建一个两倍于原容量的数组，然后将原数组里的元素进行再hash后插入到新的数组里，不会对整个容器进行扩容，而只对某个segment进行扩容。**
>
> put流程：将当前segment中的table通过key的hashcode定位到HashEntry，遍历该HashEntry，如果不为空则判断传入的key和当前遍历的key是否相等，相等则覆盖旧的value。为空则需新建一个HashEntry并加入到segment中，同时会先判断是否需要扩容，最后解除当前segment锁。
>
> 查询遍历链表效率太低，**JDK1.8抛弃了原有的segment分段锁，采用了CAS+Synchronized保证并发安全性**。新版的JDK中对Synchronized优化是很到位的。

总结：读操作（几乎）不需要加锁，而**在写操作时通过锁分段技术只对所操作的段加锁而不影响客户端对其它段的访问**。ConcurrentHashMap本质上是一个segment数组，而一个segment实例又包含若干个桶，每个桶中都包含一条由若干个HashEntry对象链接起来的链表，ConcurrentHashMap的高效并发机制是通过以下三方面来保证的；

- **通过锁分段技术保证并发环境下的写操作；** 
- **通过 HashEntry的不变性、Volatile变量的内存可见性和加锁重读机制保证高效、安全的读操作；** 
- **通过不加锁和加锁两种方案控制跨段操作的的安全性。** 

附：

自旋锁和阻塞锁区别：要不要放弃处理器的执行时间。**对于阻塞锁和自旋锁来说，都是要等待获得共享资源**，但是阻塞锁是放弃了cpu时间，进入了等待区，等待被唤醒。而自旋锁一直“自旋”在那里，时刻的检查共享资源是否可以被访问。

CAS：是项**乐观锁技术**，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其他线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。

### Java并发

1、多线程创建方式？

- 继承Thread类创建线程；当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。 
- 实现Runnable接口创建线程；需要实现 run() 方法，通过 Thread 调用 start() 方法来启动线程。 
- 实现Callable接口通过FutureTask包装器来创建Thread线程，与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。 
- 使用ExecutorService、Callable、Future实现有返回结果的线程 。

2、Java如何实现线程同步？

- 同步方法  `synchronized` 关键字修饰的方法（悲观锁） 

- 使用特殊域变量(`volatile`)实现线程同步（保持可见性，多线程更新某一个值时，案例线程安全单例双检查锁） 

- `ThreadLocal`（每个线程获取的都是该变量的副本） 

- 使用重入锁实现线程同步（相对synchronized锁粒度更细了，效率高）

  > 一个java.util.concurrent包来支持同步。 
  >
  > ​         `ReentrantLock`类是可重入、互斥、实现了Lock接口的锁
  >
  > ​         ReentrantLock() : 创建一个ReentrantLock实例 
  >
  > ​            lock() : 获得锁 
  >
  > ​            unlock() : 释放锁 

- java.util.concurrent.atomic包 （乐观锁） 

  > ​           方便程序员在多线程环境下，无锁的进行原子操作
  >
  > ​            AtomicInteger
  >
  > ​            CAS，Compare and Swap即比较并交换。java.util.concurrent包**借助CAS实现了区别于synchronized同步锁的一种乐观锁**。乐观锁就是每次去取数据的时候都乐观的认为数据不会被修改，所以不会上锁，但是在更新的时候会判断一下在此期间数据有没有更新。CAS有3个操作数：内存值V，旧的预期值A，要修改的新值B

3、线程状态转换？

![](img\线程转换状态.PNG)

- 新建（New）：创建后尚未启动；

- 可运行（Runnable）：可能正在运行，也可能正在等待 CPU 时间片。 包含了操作系统线程状态中的 Running 和 Ready。 

- 阻塞（Blocked）：等待获取一个排它锁，如果其线程释放了锁就会结束此状态。 

- 无限期等待（Waiting）：等待其它线程显式地唤醒，否则不会被分配 CPU 时间片。 

- 限期等待（Timed Waiting）：无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。

  调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。

  调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。

- 死亡（Terminated）：可以是线程结束任务之后自己结束，或者产生了异常而结束。

4、互斥同步？

Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问， synchronized和ReentrantLock。 

共同点：

> 都是用来协调多线程对共享对象、变量的访问 
>
> 都是可重入锁，同一线程可以多次获得同一个锁
>
> 都保证了可见性和互斥性    

不同点：

> 锁的实现 ：**synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的**。 
>
> 性能：新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。 
>
> 等待可中断 ：当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。**ReentrantLock 可中断，而 synchronized 不行。**
>
> 公平锁：公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。
>
> synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。
>
> 锁绑定多个条件：一个 ReentrantLock 可以同时绑定多个 Condition 对象。 

使用选择：

除非需要使用 ReentrantLock 的高级功能，否则**优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它**，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized **不用担心没有释放锁而导致死锁问题**，因为 JVM 会确保锁的释放。 

5、线程之间的协作？

当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调。 

- join（）：在线程中调用另一个线程的 join() 方法，会**将当前线程挂起，而不是忙等待，直到目标线程结束。** 
- wait() notify() notifyAll()：调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。它们都**属于 Object 的一部分**，而不属于 Thread。 
- await() signal() signalAll()：java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。相比于 wait() 这种等待方式，**await() 可以指定等待的条件，因此更加灵活**。

6、wait() 和 sleep() 的区别？

- wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法；
- sleep()方法导致了程序暂停执行指定的时间，让出 cpu 该其他线程，但是他的监控状态依然 保持者，当指定的时间到了又会自动恢复运行状态；    
- wait() 会释放锁，sleep() 不会；
- 当调用 wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用 notify()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。    

7、start 与 run 区别 ？

- start（） 方法来启动线程，真正实现了多线程运行。这时无需等待 run 方法体代码执行完毕， 可以直接继续执行下面的代码；
- 通过调用 Thread 类的 start()方法来启动一个线程， 这时此线程是处于就绪状态， 并没有运行 ；
- 方法 run()称为线程体，它包含了要执行的这个线程的内容，线程就进入了运行状态，开始运行 run 函数当中的代码。 Run 方法运行结束， 此线程终止。然后 CPU 再调度其它线程。      

8、多线程是什么？

多线程是为了**同步完成多项任务**，不是为了提高运行效率，而是为了**提高资源使用效率来提高系统的效率**。线程是在同一时间需要完成多项任务的时候实现的。 对那些可共享的资源来说(比如打印机)，它们在使用期间必须进入锁定状态。所以一个线程可将资源锁定，在完成了它的任务后，再解开(释放)这个锁，使其他线程可以接着使用同样的资源。 

一个采用了多线程技术的应用程序可以更好地利用系统资源。其主要优势在于**充分利用了CPU的空闲时间片**，可以用尽可能少的时间来对用户的要求做出响应，使得进程的整体运行效率得到较大提高，同时增强了应用程序的灵活性。更为重要的是，由于**同一进程的所有线程是共享同一内存，所以不需要特殊的数据传送机制**，不需要建立共享存储区或共享文件，从而使得不同任务之间的协调操作与运行、数据的交互、资源的分配等问题更加易于解决。 

9、Volatile？

一旦一个共享变量（类的成员变量、类的静态成员变量）**被volatile修饰**之后：

> - 保证了**不同线程对这个变量进行操作时的可见性**，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
> - **禁止进行指令重排序**。 

10、死锁的原因？如何打破？

死锁是指**在一组进程中的各个进程均占有不会释放的资源，但因互相申请被其他进程所站用不会释放的资源而处于的一种永久等待状态**。死锁的四个必要条件： 

> •   互斥条件(Mutual exclusion)：资源不能被共享，只能由一个进程使用。
>
> •   请求与保持条件(Hold and wait)：已经得到资源的进程可以再次申请新的资源。
>
> •   非剥夺条件(No pre-emption)：已经分配的资源不能从相应的进程中被强制地剥夺。
>
> •   循环等待条件(Circular wait)：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源。

java中产生死锁可能性的最根本原因是 ：

- 是多个线程涉及到多个锁，这些锁存在着交叉，所以可能会导致了一个锁依赖的闭环；
- 默认的锁申请操作是阻塞的。 

如，线程在获得一个锁L1的情况下再去申请另外一个锁L2，也就是锁L1想要包含了锁L2，在获得了锁L1，并且没有释放锁L1的情况下，又去申请获得锁L2，这个是产生死锁的最根本原因。 

避免死锁：

> - 破坏死锁的循环等待条件。
> - 破坏死锁的请求与保持条件，使用lock的特性，为获取锁操作设置超时时间。这样不会死锁（至少不会无尽的死锁） 
> - 设置一个条件遍历与一个锁关联。该方法只用一把锁，没有chopstick类，将竞争从对筷子的争夺转换成了对状态的判断。仅当左右邻座都没有进餐时才可以进餐。提升了并发度。 

11、notify 与 notifyAll？

Object 类中的 notify() 方法， **唤醒在此对象监视器上等待的单个线程**，如果所有线程都在此对象上等待，则会选择唤醒其中一个线程，选择是任意的，并在对实现做出决定时发生，线程通过调用其中一个 wait() 方法，在对象的监视器上等待， 直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程，被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争。**notifyAll() ，唤醒监视器上等待的所有线程**。    

12、ThreadLocal ？

ThreadLocal，叫做**线程本地变量**，也叫做线程本地存储， ThreadLocal 的作用是**提供线程内的局部变量， 这种变量在线程的生命周期内起作用**，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。   

13、解释一下什么是线程池（thread pool）？

在面向对象编程中，**创建和销毁对象是很费时间的**，因为创建一个对象要获取内存资源或者其它更多资源。在Java中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是**尽可能减少创建和销毁对象的次数**，特别是一些很耗资源的对象创建和销毁，这就是”池化资源”技术产生的原因。线程池顾名思义就是**事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。** 

### Java设计模式

#### 单例模式

1、单例模式(Singleton Pattern)：单例模式**确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例**，这个类称为单例类，它**提供全局访问的方法**。 

2、单例模式的要点有三个：

- 某个类只能有一个实例；
- 它必须自行创建这个实例；
- 它必须自行向整个系统提供这个实例。

3、优缺点？

优点：**节约资源，节省时间**。

- 由于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级的对象而言，是很重要的。
- 因为不需要频繁创建对象，我们的GC压力也减轻了。

缺点：简单的单例模式设计开发都比较简单，但是**复杂的单例模式需要考虑线程安全等并发问题**，引入了部分复杂度。**职责过重**（既充当工厂角色，提供工厂方法，同时又充当了产品角色。包含一些业务方法）。

4、三要素：

- 一个静态类变量；
- 一个私有构造方法；
- 一个全局静态的类方法。

5、类型：懒汉式（线程不安全）、饿汉式（天生线程安全）。

饿汉式：初始化类时，直接就创建唯一实例；

（1）

```java
public class Singleton {
    private static Singleton instance = new Singleton();////私有静态变量
    private Singleton() {}//私有构造函数
    public static Singleton getInstance() {//公有静态函数
        return instance;
    }
}
```

（2）枚举方式：（线程安全，**可防止反射构建**），在枚举类对象被反序列化的时候，保证反序列的返回结果是同一对象。

```java
public enum Singleton {
    INSTANCE;
}
```

懒汉式：

（1）双重校验锁：

```java
//第一次判断 instance是否为空是为了确保返回的实例不为空
//第二次判断 instance是否为空是为了防止创建多余的实例
public class Singleton {
    private volatile static Singleton instance = null;
    private Singleton() {}
    public static Singleton getInstance() {
        if(instance == null) {
            synchronized(Singleton.class){
                if(instance == null) {//线程B
                    instance = new Singleton();//并非是一个原子操作    线程A
                    /**
                    * 会被编译器编译成如下JVM指令：
                    * memory = allocate(); - 1、分配对象的内存空间
                    * ctorInstance(memory); - 2、初始化对象
                    * instance = memory; - 3、设置instance指向刚分配的内存地址
                    */
                }
            }
        }
        return instance;
    }
}
```

synchronized同步块里面能够保证只创建一个对象。但是**通过在synchronized的外面增加一层判断，就可以在对象一经创建以后，不再进入synchronized同步块。这种方案不仅减小了锁的粒度，保证了线程安全，性能方面也得到了大幅提升。** 进入Synchronized 临界区以后，还要再做一次判空。因为当两个线程同时访问的时候，线程A构建完对象，线程B也已经通过了最初的判空验证，不做第二次判空的话，线程B还是会再次构建instance对象。 

Volatile：

- 可见性；
- 防止指令重排序：**防止new Singleton时指令重排序导致其他线程获取到未初始化完的对象**。指令顺序并非一成不变，有可能会经过JVM和CPU的优化，指令重排成下面的顺序：1，3，2。在3执行完毕，2未执行之前，被线程2抢占了，这时instance已经是非null了（但却没有初始化），所以线程2会直接返回instance，然后使用，报错。

（2）静态内部类：线程安全，懒加载

```java
//INSTANCE对象初始化的时机并不是在单例类Singleton被加载的时候，而是在调用getInstance方法，使得静态内部类SingletonHolder被加载的时候。因此这种实现方式是利用classloader的加载机制来实现懒加载，并保证构建单例的线程安全。
public class Singleton {
    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }
    private Singleton() {}
    public static Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}
```

#### 观察者模式

1、定义了对象之间的一对多依赖关系，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并且自动更新。

2、观察者模式具备：事件的源、事件对象、事件处理对象。以西游记为例，唐僧就是事件源，孙悟空、猪八戒、沙僧都是事件处理对象，事件对象包含有关事件和事件的源信息（就是记录唐僧发生事件的信息）。

事件源类三要素：

- 私有的监听者列表
- 公有的向监听者列表添加监听者的方法
- 公有的发生事情的方法

### Junit

1、junit：开源的Java单元测试框架、设计思想是通过从零开始来应用设计模式，然后一个接一个，直至获得最终合适的系统架构。

2、使用到的设计模式：

- Template Method（模板方法）：需要复用的是算法的结构，也就是步骤，而步骤的实现可以在子类中完成。

  在Junit中的应用：@Before、@Test、@After

- Command（命令）模式：将一个请求封装成一个对象，从而使你可用不同的请求对客户进行参数化，可以为一个操作生成一个对象并给出它的一个execute（执行）方法。Command模式**使新的TestCase很容易的加入**，无需改变已有的类，只需继承TestCase类即可，这样方便了测试人员。

- Composite（组合）：把多个测试用例进行组合成为一个符合的测试用例，当作一个请求发送给Junit。

- Dapter（适配器）：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。在Junit中的应用：testXXX（）。通过**runTest方法将我们自己编写的testXXX方法进行了适配**，使得junit可以执行我们自己编写的Test Case。 



## Web基础

1、怎么防止前端重复提交 ？  

- 提交按钮后屏蔽提交按钮(前端js控制) ；
- 前端生产唯一id，后端通过唯一索引；
- 利用Session防止表单重复提交。

2、批量往mysql导入1000万数据有什么方法？

- 减少IO次数：一条SQL语句插入多条数据 ；
- SQL写法优化；
- 在事务中进行插入处理，切记不要1条数据提交一下，肯定要分批处理 ；
- 数据有序插入，是为了减少索引的维护压力；
- 实际开发时需要合理设置MYSQL相应配置参数，增加缓存或减少不必要日志磁盘读写。

3、git？git合代码一般怎么操作，遇到冲突又怎么办？ 

git：分布式，多人开发，版本迭代比较快的项目，建议使用git。 

注意：git_项目版本编号  就是你项目拉的分支流编号 

遇到冲突思路：

- 把你当前分支 copy出一个临时分支出来
- 临时分支和master 合并下 ，有冲突请解决掉(比较耗时的就是这一步)
- 把临时分支合到当前开发分支 （这时候肯定没冲突了）
- 把当前开发分支合到master

> 具体解决冲突命令：
>
> ```
> 1、基于待合并的迭代分支  checkout 新分支 merge_master
> git checkout master
> git pull -p
> 2、执行 git merge master 并解决冲突
> git checkout git_项目版本编号
> git checkout -b merge_master-for-git_项目版本编号    【分支克隆】
> git merge master   【执行这步会更新很多代码下来，有冲突就要解决,需要手动解决掉，确认不要覆盖代码】
> 3、push merge_master-for- 分支 
> git push origin merge_master-for-git_项目版本编号
> 4、最后合会分支 git_项目版本编号
> git checkout git_项目版本编号
> git merge merge_master-for-git_项目版本编号
> git push origin git_项目版本编号
> ```

4、B / S 与 C / S ？

1）C / S ：Client / server 的简写，这里 Server 指的是 DBServer。

- 特点：**每个客户端必须安装（部署）一份应用程序，一般在局域网使用，只针对特定的客户群**；
- **响应速度快，交互比较好**；
- 缺点：**客户端数目受服务器限制，维护升级比较麻烦**；
- 开发技术： vb，Delphi，winforms，AWT/Swing，SWT。

2）B / S：Brower/Server 的简写，这里的 Server 指的有两个，WebServer 与 DBServer。

- 特点：**客户端不需要部署应用程序，只要一个浏览器**。一般 web 网使用，但新的趋势是 B/S 项目越来越多，甚至传统使用 C/S 开发的项目也使用 B/S。富客户端技术（ajax，jquery，flex 等）的兴起，使 B/S 更如日中天。
- 优点：**程序升级维护方便，代码只在 WebServer 中有一份**。因为最终程序运行结果在客户浏览器中显示，所以对客户端平台无限制。
- 缺点：**交互式没有 C/S 好**。

5、Jsp？Servlet？

JSP 微观定义： Java Server Page 的简写，文件后缀为 jsp。 JSP 页面=DHTML(html+css+js)+JAVA。其**转译后为一 Servlet**。 

Servlet 微观定义： Servlet 是一个可以部署到 webServer 可以被客户端访问的 **Java 类**。 

6、Servlet 类与普通 Java 类的区别 ？

![](img\servlet-java.png)

7、Servlet 的生命周期？

![](img\servlet生命周期.png)

- 构造方法（实例化）与 init(初始化)方法是一起执行的，要么第一次访问时执行，要么是 web 程序启动时执行。当加上1时，两个方法在 web 应用程序启动时调用，多个调用顺序 0,1,2,3。
- init()调用一次，一般第一次访问 Servlet 时调用。 service()调用多次，每次访问时调用。也有可能调用 0 次。
- destroy()调用一次， 应用程序关闭时调用（服务器关了，应用程序一定关；程序关闭，服务器不一定关）

![](img\servlet生命周期 (1).png)

- 实例化，或称创建， new，创建对象，分配内存空间。由容器完成。
- 初始化，指的是调用 init 方法，在对象实例化后执行。完成初始 servlet 要使用的资源，给变量赋初值等工作。
- 服务，调用 service 方法。
- 销毁， destroy,释放初始化占用的资源。
- 不可用，垃圾回收车收集内存。

8、request重要方法？

- request.getContextPath()：得到 web 应用程序名称，或者叫虚拟路径，一般默认为项目名，但可以不一致。
- request.getServletPath()： 如果请求的是 servlet，那么返回的该servlet 在 web.xml 中配置的 url-pattern；如果是 jsp，返回 jsp 文件名。
- request.getRequestURI() = request.getContextPath() + request.getServletPath()；请求的相对路径
- request.getRequestURL()：请求的全部路径，绝对路径
- request.getMethod()： 请求类别，默认是 get 请求，只有使用 form 表单提交才可以使用 post 请求。
- request.getRemotePort()：客户端端口
- request.getRemoteAddr()：得到客户端的 IP 地址
- request.getServerName()：得到服务器名称
- request.getServerPort()：得到服务器端口号

9、请求转发 与 重定向？

请求转发：

> - 请求转发需要 RequestDispatcher 的支持 ， 通 过request.getRequestDispatcher 方法得到 RequestDispatcher 对象 。RequestDispatcher 的 forward 方法传递 request 与 response。
> - 请求转发。 request 数据从第一个 servlet 到第二个 servlet 不会丢失，因为使用的是同一个 request。
> - 请求转发只能在一个 webApp 内部转发。
> - 如果请求的第一个 servlet 方法是 doGet，那么转发给其它 Servlet 的方法也是 doGet，也就是说，所有的请求方法类别一致。
> - 请求转发地址栏显示的依然是第一个请求资源路径。

重定向：

> - 使用 response.sendRedirect（）方法。没有传递 request对象。
> - request 数据从第一个 servlet 到第二个 servlet 会丢失，因为使用的不是同一个 request。
> - 重定向可以定向到其它应用程序。
> - 不管第一个请求是 get 还是 post,定向后全部变为默认的 get。
> - 从定向 url 地址栏路径改变，显示的最后一个。
> - 请求转发 url 地址栏路径不变，重定向改变。

请求转发 VS 重定向 ：

> - 请求转发可以传递数据（数据不会丢失），重定向不能传递数据（数据会丢失）。
> - 请求转发只能在一个 web 应用程序内部转发，重定向可以到其他应用程序。
> - 请求转发处理完， 地址栏 url 路径为第一个（servlet）资源路径。 重定向为最后一个资源路径。 （利用重定向防止表单重复提交。）
> - 请求转发不需要加 webApp 名称。重定向需要添加 webApp 名称，但如果是定向到一个程序内部，添加有些繁琐，这时可以不添加，但资源路径不能再写“/“
> - 请求转发后面调用的方法类别与前面相同，而重定向全部会变为 get 请求，与之前的没关系。
> - 请求转发是一次请求（只有一个 request 对象），重定向是多次请求（生成多个 request 对象）。

10、request 中 parameter 与 attribute 的区别？

- parameter 是客户端传过来的（client 请求参数）数据， attribute 是在 Server 端放入的数据。
- parameter 数据是只读的， attribute 是可读写的， parameter 相关的方法有 request.getParamenter();与 attribute 相关的方法有 setAttribute(String,Object)， getAttribute(String)，removeAttribute(String)
- getParameter返回的是 String类型，而 getAttribute返回的是 Object类型，需要强转

11、Jsp执行原理？

![](img\jsp执行原理.png)

12、Session VS Cookie ？

![](img\session-cookie.png)



### Spring

1、说一下Spring AOP？Spring AOP的原理？

AOP（Aspect Oriented Programming），即**面向切面编程**，可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过**OOP允许开发者定义纵向的关系，但并不适合定义横向的关系**，例如日志功能。**日志代码往往横向地散布在所有对象层次中，而与它对应的对象的核心功能毫无关系对于其他类型的代码，如安全性、异常处理和透明的持续性也都是如此，这种散布在各处的无关的代码被称为横切（cross cutting），在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。**

AOP技术恰恰相反，它利用一种称为"横切"的技术，**剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为"Aspect"，即切面。所谓"切面"，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。**

使用"横切"技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事物。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。

原理：

- 通过**预编译方式和运行期动态代理方式实现程序功能的统一维护**的一种技术；
- 主要功能：**日志记录、性能统计、安全控制、事务处理、异常处理**等等；
- AOP实现方式 ：
  - 预编译：AspectJ 
  - 运行期动态代理（JDK动态代理、CGLib动态代理）：SpringAOP、JbossAOP 
- 面向切面的核心思想就是，**让核心的业务逻辑代码，不需要去管理一些通用的逻辑，比如说事务，安全等这方面的共同逻辑，解耦业务逻辑和通用逻辑** 。

2、SpringMVC主流程 ?

核心类与接口：

- DispatcherServlet 前置控制器
- HandlerMapping 请求映射（到Controller）
- HandlerAdapter 请求映射（到Controller类的方法上）
- Controller 控制器
- HandlerIntercepter 拦截器
- ViewResolver 视图映射
- View 视图处理

![](img\springmvc.PNG)

> - 客户端的所有请求都交给前端控制器DispatcherServlet来处理，它会负责调用系统的其他模块来真正处理用户的请求。
> - DispatcherServlet收到请求后，将根据请求的信息（包括URL、HTTP协议方法、请求头、请求参数、Cookie等）以及HandlerMapping的配置找到处理该请求的Handler（任何一个对象都可以作为请求的Handler）。
> - 在这个地方Spring会通过HandlerAdapter对该处理器进行封装。 
> - HandlerAdapter是一个适配器，它用统一的接口对各种Handler中的方法进行调用。
> - Handler完成对用户请求的处理后，会返回一个ModelAndView对象给DispatcherServlet，ModelAndView顾名思义，包含了数据模型以及相应的视图的信息。 
> - ModelAndView的视图是逻辑视图，DispatcherServlet还要借助ViewResolver完成从逻辑视图到真实视图对象的解析工作。
> - 当得到真正的视图对象后，DispatcherServlet会利用视图对象对模型数据进行渲染。
> - 客户端得到响应，可能是一个普通的HTML页面，也可以是XML或JSON字符串，还可以是一张图片或者一个PDF文件。 

- 用户发送请求时会先从DispathcherServler的doService方法开始，在该方法中会将ApplicationContext、localeResolver、themeResolver等对象添加到request中，紧接着就是调用doDispatch方法。
- 进入该方法后首先会检查该请求是否是文件上传的请求(校验的规则是是否是post并且contenttType是否为multipart/为前缀)即调用的是checkMultipart方法；如果是的将request包装成MultipartHttpServletRequest。
- 然后调用getHandler方法来匹配每个HandlerMapping对象，如果匹配成功会返回这个Handle的处理链HandlerExecutionChain对象，在获取该对象的内部其实也获取我们自定定义的拦截器，并执行了其中的方法。
- 执行拦截器的preHandle方法，如果返回false执行afterCompletion方法并理解返回
- 通过上述获取到了HandlerExecutionChain对象，通过该对象的getHandler()方法获得一个object通过HandlerAdapter进行封装得到HandlerAdapter对象。
- 该对象调用handle方法来执行Controller中的方法，该对象如果返回一个ModelAndView给DispatcherServlet。
- DispatcherServlet借助ViewResolver完成逻辑试图名到真实视图对象的解析，得到View后DispatcherServlet使用这个View对ModelAndView中的模型数据进行视图渲染。

3、线程池的处理流程？

![](img\线程池的处理流程.PNG)

> 线程池核心参数：
>
> ```java
> <bean id="testExecutor"
>       class="org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor">
> <!-- corePoolSize  -->
> <property name ="corePoolSize" value ="5" />
> <!-- 线程池维护线程的最大数量 -->
> <property name ="maxPoolSize" value ="10" />
> <!-- 线程池所使用的缓冲队列 -->
> <property name ="queueCapacity" value ="1000" />
> <!-- keepAliveSeconds  线程池维护线程所允许的空闲时间 -->
> <property name ="keepAliveSeconds" value ="3000" />
> <!-- 核心线程在空闲keepAliveSeconds后也timeout -->
> <property name ="allowCoreThreadTimeOut" value ="true" />
> <!-- 设置线程名称 -->
> <property name="threadNamePrefix" value="studyOrderTaskThreadPool-thread-"/>
> </bean>
> ```

4、spring bean生命周期？（这个问题其实是考察你对spring接口的一个熟悉程度，回答不全不要慌，能说几个是几个 ）

![](img\spring_bean.png)

![](img\bean.PNG)



下面以BeanFactory为例，说明一个Bean的生命周期活动：

> - Bean的建立， 由BeanFactory读取Bean定义文件，并生成各个实例
> - Setter注入，执行Bean的属性依赖注入
> - BeanNameAware的setBeanName(), 如果实现该接口，则执行其setBeanName方法
> - BeanFactoryAware的setBeanFactory()，如果实现该接口，则执行其setBeanFactory方法
> - BeanPostProcessor的processBeforeInitialization()，如果有关联的processor，则在Bean初始化之前都会执行这个实例的processBeforeInitialization()方法
> - InitializingBean的afterPropertiesSet()，如果实现了该接口，则执行其afterPropertiesSet()方法
> - Bean定义文件中定义init-method
> - BeanPostProcessors的processAfterInitialization()，如果有关联的processor，则在Bean初始化之前都会执行这个实例的processAfterInitialization()方法
> - DisposableBean的destroy()，在容器关闭时，如果Bean类实现了该接口，则执行它的destroy()方法
> - Bean定义文件中定义destroy-method，在容器关闭时，可以在Bean定义文件中使用“destory-method”定义的方法

> - Spring容器 从XML 文件中读取bean的定义，并实例化bean。
> - Spring根据bean的定义填充所有的属性。
> - 如果bean实现了BeanNameAware 接口，Spring 传递bean 的ID 到 setBeanName方法。
> - 如果Bean 实现了 BeanFactoryAware 接口， Spring传递beanfactory 给setBeanFactory 方法。
> - 如果有任何与bean相关联的BeanPostProcessors，Spring会在postProcesserBeforeInitialization()方法内调用它们。
> - 如果bean实现IntializingBean了，调用它的afterPropertySet方法，如果bean声明了初始化方法，调用此初始化方法。
> - 如果有BeanPostProcessors 和bean 关联，这些bean的postProcessAfterInitialization() 方法将被调用。
> - 如果bean实现了 DisposableBean，它将调用destroy()方法。

5、MyBatis有什么优势，他如何做事务管理？

MyBatis优点： 

- 易于上手和掌握
- **sql写在xml里，便于统一管理和优化**。
- **解除sql与程序代码的耦合**。
- 提供映射标签，**支持对象与数据库的orm字段关系映射**
- 提供对象关系映射标签，支持对象关系组建维护
- 提供xml标签，支持编写动态sql。

Mybatis管理事务是分为两种方式：

> 使用JDBC的事务管理机制，就是利用java.sql.Connection对象完成对事务的提交
>
> 使用MANAGED的事务管理机制，这种机制mybatis自身不会去实现事务管理，而是让程序的容器（JBOSS,WebLogic）来实现对事务的管理

6、说明一下springmvc和spring-boot区别是什么？

总的来说，Spring 就像一个大家族，有众多衍生产品例如 Boot，Security，JPA等等。但他们的基础都是Spring 的 IOC 和 AOP，IOC提供了依赖注入的容器，而AOP解决了面向切面的编程，然后在此两者的基础上实现了其他衍生产品的高级功能；因为 Spring 的配置非常复杂，各种xml，properties处理起来比较繁琐。于是为了简化开发者的使用，Spring社区创造性地推出了Spring Boot，它遵循约定优于配置，极大降低了Spring使用门槛，但又不失Spring原本灵活强大的功能。 

7、Spring中自动装配的方式有哪些？

- no：不进行自动装配，手动设置Bean的依赖关系。
- byName：根据Bean的名字进行自动装配。
- byType：根据Bean的类型进行自动装配。
- constructor：类似于byType，不过是应用于构造器的参数，如果正好有一个Bean与构造器的参数类型相同则可以自动装配，否则会导致错误。
- autodetect：如果有默认的构造器，则通过constructor的方式进行自动装配，否则使用byType的方式进行自动装配。

自动装配没有自定义装配方式那么精确，而且不能自动装配简单属性（基本类型、字符串等），在使用时应注意。

8、什么是IoC和DI？并且简要说明一下DI是如何实现的？

IoC叫控制反转，是Inversion of Control的缩写，**DI（Dependency Injection）叫依赖注入，是对IoC更简单的诠释**。控制反转是把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的**"控制反转"就是对组件对象控制权的转移，从程序代码本身转移到了外部容器，由容器来创建对象并管理对象之间的依赖关系。**IoC体现了好莱坞原则 - "Don’t call me, we will call you"。依赖注入的基本原则是应用组件不应该负责查找资源或者其他依赖的协作对象。配置对象的工作应该由容器负责，查找资源的逻辑应该从应用组件的代码中抽取出来，交给容器来完成。DI是对IoC更准确的描述，即组件之间的依赖关系由容器在运行期决定，形象的来说，即由容器动态的将某种依赖关系注入到组件之中。

一个类A需要用到接口B中的方法，那么就需要为类A和接口B建立关联或依赖关系，最原始的方法是在类A中创建一个接口B的实现类C的实例，但这种方法需要开发人员自行维护二者的依赖关系，也就是说当依赖关系发生变动的时候需要修改代码并重新构建整个系统。如果通过一个容器来管理这些对象以及对象的依赖关系，则只需要在类A中定义好用于关联接口B的方法（构造器或setter方法），将类A和接口B的实现类C放入容器中，通过对容器的配置来实现二者的关联。
依赖注入可以通过setter方法注入（设值注入）、构造器注入和接口注入三种方式来实现，Spring支持setter注入和构造器注入，通常使用构造器注入来注入必须的依赖关系，对于可选的依赖关系，则setter注入是更好的选择，setter注入需要类提供无参构造器或者无参的静态工厂方法来创建对象。

9、请说明一下springIOC原理是什么？如果你要实现IOC需要怎么做？请简单描述一下实现步骤？

①IoC（Inversion of Control，控制倒转）。这是spring的核心，贯穿始终。所谓IoC，对于spring框架来说，就是由spring来负责控制对象的生命周期和对象间的关系。

IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个Connection对象，有了 spring我们就只需要告诉spring，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，spring会在适当的时候制造一个Connection，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。A需要依赖 Connection才能正常运行，而这个Connection是由spring注入到A中的，依赖注入的名字就这么来的。那么DI是如何实现的呢？ Java 1.3之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。

举个简单的例子，我们找女朋友常见的情况是，我们到处去看哪里有长得漂亮身材又好的女孩子，然后打听她们的兴趣爱好、qq号、电话号、ip号、iq号………，想办法认识她们，投其所好送其所要，这个过程是复杂深奥的，我们必须自己设计和面对每个环节。传统的程序开发也是如此，在一个对象中，如果要使用另外的对象，就必须得到它（自己new一个，或者从JNDI中查询一个），使用完之后还要将对象销毁（比如Connection等），对象始终会和其他的接口或类藕合起来。

②实现IOC的步骤

定义用来描述bean的配置的Java类

解析bean的配置，將bean的配置信息转换为上面的BeanDefinition对象保存在内存中，spring中采用HashMap进行对象存储，其中会用到一些xml解析技术

遍历存放BeanDefinition的HashMap对象，逐条取出BeanDefinition对象，获取bean的配置信息，利用Java的反射机制实例化对象，將实例化后的对象保存在另外一个Map中即可。

10、@Controller和@RestController的区别是什么？

@RestController注解相当于@ResponseBody ＋ @Controller合在一起的作用 

11、简要说明一下IOC和AOP是什么？

依赖注入的三种方式：（1）**接口注入**（2）**Construct注入**（3）**Setter注入**

控制反转（IoC）与依赖注入（DI）是同一个概念，引入IOC的目的：（1）脱开、降低类之间的耦合；（2）倡导面向接口编程、实施依赖倒换原则； （3）提高系统可插入、可测试、可修改等特性。

具体做法：（1）将bean之间的依赖关系尽可能地抓换为关联关系；

（2）将对具体类的关联尽可能地转换为对Java interface的关联，而不是与具体的服务对象相关联；

（3）Bean实例具体关联相关Java interface的哪个实现类的实例，在配置信息的元数据中描述；

（4）由IoC组件（或称容器）根据配置信息，实例化具体bean类、将bean之间的依赖关系注入进来。

AOP（Aspect Oriented Programming），即面向切面编程，可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过**OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能**。日志代码往往横向地散布在所有对象层次中，而与它对应的对象的核心功能毫无关系对于其他类型的代码，如安全性、异常处理和透明的持续性也都是如此，这种散布在各处的无关的代码被称为横切（cross cutting），在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。

AOP技术恰恰相反，它利用一种称为"横切"的技术，**剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块**，并将其命名为"Aspect"，即切面。所谓"切面"，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。

使用"横切"技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事物。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。

12、Spring支持的事务管理类型有哪些？以及你在项目中会使用哪种方式？ 

Spring支持**编程式事务管理和声明式事务管理**。许多Spring框架的用户选择声明式事务管理，因为这种方式和应用程序的关联较少，因此更加符合轻量级容器的概念。声明式事务管理要优于编程式事务管理，尽管在灵活性方面它弱于编程式事务管理，因为编程式事务允许你通过代码控制业务。

事务分为全局事务和局部事务。全局事务由应用服务器管理，需要底层服务器JTA支持（如WebLogic、WildFly等）。局部事务和底层采用的持久化方案有关，例如使用JDBC进行持久化时，需要使用Connetion对象来操作事务；而采用Hibernate进行持久化时，需要使用Session对象来操作事务。

这些事务的父接口都是PlatformTransactionManager。Spring的事务管理机制是一种典型的策略模式，PlatformTransactionManager代表事务管理接口，该接口定义了三个方法，该接口并不知道底层如何管理事务，但是它的实现类必须提供getTransaction()方法（开启事务）、commit()方法（提交事务）、rollback()方法（回滚事务）的多态实现，这样就可以用不同的实现类代表不同的事务管理策略。使用JTA全局事务策略时，需要底层应用服务器支持，而不同的应用服务器所提供的JTA全局事务可能存在细节上的差异，因此实际配置全局事务管理器是可能需要使用JtaTransactionManager的子类，如：WebLogicJtaTransactionManager（Oracle的WebLogic服务器提供）、UowJtaTransactionManager（IBM的WebSphere服务器提供）等。

13、aop的应用场景有哪些？

Authentication 权限 ，Caching 缓存 ，Context passing 内容传递 ，Error handling 错误处理 ，Lazy loading 懒加载 ，Debugging 调试 ，logging, tracing, profiling and monitoring 记录跟踪　优化　校准，Performance optimization 性能优化 ，Persistence 持久化 ，Resource pooling 资源池 ，Synchronization同步，Transactions 事务。 

14、Spring框架为企业级开发带来的好处有哪些？

> - 非侵入式：支持基于POJO的编程模式，不强制性的要求实现Spring框架中的接口或继承Spring框架中的类。
> - IoC容器：IoC容器帮助应用程序管理对象以及对象之间的依赖关系，对象之间的依赖关系如果发生了改变只需要修改配置文件而不是修改代码，因为代码的修改可能意味着项目的重新构建和完整的回归测试。有了IoC容器，程序员再也不需要自己编写工厂、单例，这一点特别符合Spring的精神"不要重复的发明轮子"。
> - AOP（面向切面编程）：将所有的横切关注功能封装到切面（aspect）中，通过配置的方式将横切关注功能动态添加到目标代码上，进一步实现了业务逻辑和系统服务之间的分离。另一方面，有了AOP程序员可以省去很多自己写代理类的工作。
> - MVC：Spring的MVC框架为Web表示层提供了更好的解决方案。
> - 事务管理：Spring以宽广的胸怀接纳多种持久层技术，并且为其提供了声明式的事务管理，在不需要任何一行代码的情况下就能够完成事务管理。
> - 其他：选择Spring框架的原因还远不止于此，Spring为Java企业级开发提供了一站式选择，你可以在需要的时候使用它的部分和全部，更重要的是，甚至可以在感觉不到Spring存在的情况下，在你的项目中使用Spring提供的各种优秀的功能。 

15、简单介绍一下spring？

> Spring是一个轻量级框架，可以一站式构建你的企业级应用。
>
> Spring的模块大概分为6个。分别是：
>
> 1、Core Container（Spring的核心）【重要】
>
> 2、AOP（面向切面变成）【重要】
>
> 3、Messaging（消息发送的支持）
>
> 4、Data Access/Integration（数据访问和集成）
>
> 5、Web（主要是SpringWeb内容，包括MVC）【重要】
>
> 6、Test（Spring测试支持，包含JUint等测试单元的支持） 7、Instrumentation（设备支持，比如Tomcat的支持）

16、持久层设计要考虑的问题有哪些？请谈一下你用过的持久层框架都有哪些？

> 所谓"持久"就是**将数据保存到可掉电式存储设备中以便今后使用**，简单的说，就是**将内存中的数据保存到关系型数据库、文件系统、消息队列等提供持久化支持的设备中**。持久层就是系统中专注于实现数据持久化的相对独立的层面。
>
> 持久层设计的目标包括：
>
> - 数据存储逻辑的分离，提供抽象化的数据访问接口。
> - 数据访问底层实现的分离，可以在不修改代码的情况下切换底层实现。
> - 资源管理和调度的分离，在数据访问层实现统一的资源调度（如缓存机制）。
> - 数据抽象，提供更面向对象的数据操作。
>
> 持久层框架有：
> \- Hibernate
> \- MyBatis
> \- TopLink
> \- Guzz
> \- jOOQ
> \- Spring Data
> \- ActiveJDBC

17、MyBatis中的动态SQL是什么意思？

对于一些复杂的查询，我们可能会**指定多个查询条件**，但是这些条件可能存在也可能不存在，需要根据用户指定的条件动态生成SQL语句。如果不使用持久层框架我们可能需要自己拼装SQL语句，还好MyBatis提供了动态SQL的功能来解决这个问题。MyBatis中用于实现动态SQL的元素主要有：

- if 
- choose / when / otherwise
- trim
- where
- set
- foreach 

18、Spring 框架中都用到了哪些设计模式？ 

Spring 框架中使用到了大量的设计模式，下面列举了比较有代表性的：1、代理模式—在 AOP 和 remoting 中被用的比较多。2、单例模式：在 spring 配置文件中定义的 bean 默认为单例模式。3、模板模式：用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。4、委派模式：Spring 提供了 DispatcherServlet 来对请求进行分发。5、工厂模式：BeanFactory 用来创建对象的实例，贯穿于 BeanFactory / ApplicationContext接口的核心理念。6、代理模式：AOP 思想的底层实现技术，Spring 中采用 JDK Proxy 和 CgLib 类库。 

19、BeanFactory 和 ApplicationContext？

BeanFactory是spring中比较**原始，比较古老的Factory**。因为比较古老，所以BeanFactory无法支持spring插件，例如：AOP、Web应用等功能。

ApplicationContext是BeanFactory的子类，因为古老的BeanFactory无法满足不断更新的spring的需求，于是**ApplicationContext就基本上代替了BeanFactory的工作，以一种更面向框架的工作方式以及对上下文进行分层和实现继承，并在这个基础上对功能进行扩展**。

![](img\beanfactory-applicationContext.PNG)

20、Spring框架中的单例bean是线程安全的吗?

Spring框架并**没有对单例bean进行任何多线程的封装处理**。关于单例bean的线程安全和并发问题需要开发者自行去搞定。但实际上，大部分的Spring bean并没有可变的状态(比如Serview类和DAO类)，所以在某种程度上说Spring的单例bean是线程安全的。如果你的bean有多种状态的话（比如 View Model 对象），就需要自行保证线程安全。 



### Spring Boot

1、什么是 Spring Boot？为什么要用 Spring Boot？

Spring Boot 是 Spring 开源组织下的子项目，是 Spring 组件一站式解决方案，主要是简化了使用 Spring 的难度，简省了繁重的配置，提供了各种启动器，开发者能快速上手。 

Spring Boot 优点非常多，如：

- 独立运行
- 简化配置
- 自动配置
- 无代码生成和XML配置
- 应用监控
- 上手容易
- ...

2、Spring Boot 的配置文件有哪几种格式？它们有什么区别？

.properties 和 .yml，它们的区别主要是书写格式不同。 

1).properties

```
app.user.name = javastack
```

2).yml

```
app:
  user:
    name: javastac
```

3、Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？

启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解：

@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。

@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能： @SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })。

@ComponentScan：Spring组件扫描。

4、开启 Spring Boot 特性有哪几种方式？

1）继承spring-boot-starter-parent项目

2）导入spring-boot-dependencies项目依赖

5、Spring Boot 需要独立的容器运行吗？

可以不需要，内置了 Tomcat/ Jetty 等容器。 

6、运行 Spring Boot 有哪几种方式？

1）打包用命令或者放到容器中运行

2）用 Maven/ Gradle 插件运行

3）直接执行 main 方法运行

7、Spring Boot 自动配置原理是什么？

注解 @EnableAutoConfiguration, @Configuration, @ConditionalOnClass 就是自动配置的核心，首先它得是一个配置文件，其次根据类路径下是否有这个类去自动配置。 

8、你如何理解 Spring Boot 中的 Starters？

Starters可以理解为启动器，它包含了一系列可以集成到应用里面的依赖包，你可以一站式集成 Spring 及其他技术，而不需要到处找示例代码和依赖包。如你想使用 Spring JPA 访问数据库，只要加入 spring-boot-starter-data-jpa 启动器依赖就能使用了。 

9、SpringBoot 实现热部署有哪几种方式？

主要有两种方式：

- Spring Loaded
- Spring-boot-devtools

10、如何理解 Spring Boot 配置加载顺序？

在 Spring Boot 里面，可以使用以下几种方式来加载配置。

1）properties文件；

2）YAML文件；

3）系统环境变量；

4）命令行参数；



### 实际问题

1、关于liunx最常见问题？（在liunx中能用基本命令搜索日志定位问题，日常的环境启动排查就就够了 ，程序员必须要拥有linux日志分析能力 ）

背景：如今程序员生产的代码99%都部署在linux环境下，代码发现缺陷，程序员的第一反应是到linux下拉日志下来看。

学习目标：学会运用linux命令快速分析生产日志，用linux命令解决常见环境问题。

推荐终端工具：SecureCRT 

重点来了：

- tail【实时看日志】

  > **tail -f \*.log** 【实时查看日志，开发环境还行，生产就算了，日志猛刷啊】
  >
  > **tail -f error.log** 【实时看异常日志还是可以的】

- vi 【编辑文本】

  > **vi x.log** 【强大的vi命令】
  >
  > :wq 保存退出
  >
  > :q! 退出不保存
  >
  > Shift+g 跳至当前文本最后一行 【看最新的日志，都在最下面】
  >
  > g+g 跳至当前文本第一行

- grep 【专抓日志，grep是必备日志分析命令】

  > grep 【强大的grep，搜日志就靠它了】
  >
  > **grep -r '关键字如商品ID' \*.log 【使用频率最高】**
  >
  > **grep '关键字如商品ID' \*.log | grep 免费商品 【条件结果中，再加条件筛选下 】**
  >
  > **grep '关键字如商品ID' \*.log >> anan.txt 【相关日志输入到一个txt中，下载到本地慢慢看，我最喜欢】**
  >
  > **grep -A 2 '商品ID' \*.log 【显示商品ID及后5行】**
  >
  > grep -B 2 '商品ID' *.log 【显示商品ID及上5行】
  >
  > grep -C 2 '商品ID' *.log 【显示商品ID及上下5行】
  >
  > grep '商品ID' *.log  --col   【高亮显示商品ID，非常醒目啊】

- 杀僵尸进程

  > ps -ef | grep java 【先查java进程ID】
  >
  > kill -9 java进程ID 【生产环境谨慎使用】

- host 查域名IP 

  > **host 域名** 【查具体IP】 

- 程序员也喜欢curl 这个命令，快速查看接口是否能调通，通了会有消息返回的 【联调环境经常用】 

  > **curl 你的url请求全路径** 【查看controller接口网络通不通，蛮实用的】 

2、生产排查定位思路？

![](img\生产排查思路.PNG)

3、接口联调问题案例？

互联网项目接口联调非常重要，今天和这个系统对接明天又换了一家公司对接，联调的时候会遇到各种问题：

- 编码问题gbk、utf-8 不说了最简单的也最容易乱码的问题
- 环境不通 ping 命令  curl 命令可以帮到你，联调前一代要检查下环境
- 数据格式转换异常，接口文档没看清楚给了错误的格式，粗心问题

4、RabbitMQ 如何保证消息不丢失？

RabbitMQ一般情况很少丢失，但是不能排除意外，为了保证我们自己系统高可用，我们必须作出更好完善措施，保证系统的稳定性。 

- 消息持久化
- ACK确认机制
- 设置集群镜像模式
- 消息补偿机制
- 消息入库：顾名思义就是将要发送的消息保存到数据库中。
- 事务消息机制:由于会严重降低性能，所以一般不采用这种方法
- confirm消息确认机制

5、maven依赖包有冲突怎么解决？

Maven冲突简而言之就是需要的Maven版本和实际导入的版本不一致，从而导致了各种问题。  

> 1、打印依赖树
>
> mvn dependency:tree  >  tree.txt
>
> 2、使用Maven helper 查看依赖冲突 （插件都牛逼）
>
> Idea插件，Maven Helper，
>
> - 提供可视化的Maven树状视图。
> - 可以一键搜索所有包含该包的父包。
> - 右键直接排出
>
> 3、使用exclusion排除依赖 （这个单词很重要）

6、解决过的生产问题？

生产问题 ：

- 一个NPE问题（没有代码异常意识）
- 配置错误问题（粗心问题）
- 线程安全问题（没考虑过线程安全）
- 内存溢出问题（没考虑过数据量大小）
- GC问题（资源不及时释放）
- 业务代码问题（业务不熟悉，特别是微服务流行的当下）

这样的问题你必须结合实际项目场景去表达，然后说出后续解决方案。是**加强代码审查、还是加强测试验证、自测**等等都是解决问题的手段。

7、说几个海量数据存储常见问题以及如何解答？

例子1：给你A,B两个文件，各存放50亿条URL，每条URL占用64字节，内存限制是4G，让你找出A,B文件共同的URL。

思路：可以估计每个文件安的大小为5G×64=320G，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。

> - 分而治之/hash映射：遍历文件a，对每个url求取，然后根据所取得的值将url分别存储到1000个小文件（记为）中。这样每个小文件的大约为300M。遍历文件b，采取和a相同的方式将url分别存储到1000小文件中（记为）。这样处理后，所有可能相同的url都在对应的小文件（）中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。
> - hash统计：求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。

例子2：有10个文件，每个文件1G， 每个文件的每一行都存放的是用户的query，每个文件的query都可能重复。要你按照query的频度排序

思路：

> - hash映射：顺序读取10个文件，按照hash(query)%10的结果将query写入到另外10个文件（记为）中。这样新生成的文件每个的大小大约也1G（假设hash函数是随机的）。
> - hash统计：找一台内存在2G左右的机器，依次对用hash_map(query, query_count)来统计每个query出现的次数。注：hash_map(query,query_count)是用来统计每个query的出现次数，不是存储他们的值，出现一次，则count+1。
> - 堆/快速/归并排序：利用快速/堆/归并排序按照出现次数进行排序。将排序好的query和对应的query_cout输出到文件中。这样得到了10个排好序的文件（记为）。对这10个文件进行归并排序（内排序与外排序相结合）。

例子3：有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16个字节，内存限制大小是1M。返回频数最高的100个词

思路：

> - 分而治之/hash映射：顺序读文件中，对于每个词x，取hash(x)%5000，然后按照该值存到5000个小文件（记为x0,x1,...x4999）中。这样每个文件大概是200k左右。如果其中的有的文件超过了1M大小，还可以按照类似的方法继续往下分，直到分解得到的小文件的大小都不超过1M。
> - hash统计：对每个小文件，采用trie树/hash_map等统计每个文件中出现的词以及相应的频率。
> - 堆/归并排序：取出出现频率最大的100个词（可以用含100个结点的最小堆），并把100个词及相应的频率存入文件，这样又得到了5000个文件。最后就是把这5000个文件进行归并（类似于归并排序）的过程了。

例子4：海量日志数据，提取出某日访问百度次数最多的那个IP。

思路：

> - 分而治之/hash映射：针对数据太大，内存受限，只能是：把大文件化成(取模映射)小文件，即16字方针：大而化小，各个击破，缩小规模，逐个解决
> - hash统计：当大文件转化了小文件，那么我们便可以采用常规的Hashmap(ip，value)来进行频率统计。
> - 堆/快速排序：统计完了之后，便进行排序(可采取堆排序)，得到次数最多的IP。

8、用过哪些电商app,并比较他们的好坏？

淘宝，用的最多，的确买日用品很方便，东西齐全，但是加载首页很慢，不够流畅，此外依旧是假货横行，应当加大打假力度，

京东，只买过U盘，但是退货后钱款没到账，找客服两次未解决，不提了，后面就卸了，没什么印象了

唯品会：排版不行，购物车只能保持十五分钟这个笔者持反对意见

网易考拉:货少但相对淘宝来说可信度比较高，当然价格也比较高，经常缺货

亚马逊：除了运费贵英文看的费力没毛病



### 智力题

1、5只猫 五分钟捉5只老鼠 请问100分钟捉100只老鼠需要多少只猫？

5*X*5M=5Y

K*X*100M=100Y

K=5

需要5只猫

2、圆桌，两个人，轮流放硬币，不能重叠，半径为1，某一方不能放下去，则为输。问先手赢 后手赢。

先手赢。圆桌对称，先手放一个，后手都能找到对称的位置放，但是除了圆心。 

3、 逻辑题：3升的杯子一个，5升的杯子一个，杯子不规则形状 问怎么得到4升的水 水无限多？

> - 将3升的装满倒入5升的；
> - 再一次将3升的转满，倒入5升的，把5升装满；
> - 3升杯里剩下的就是1升水；
> - 倒掉5升的，把1升水倒入5升杯；
> - 第三次加满3升杯，倒入5升杯，得到4升水。

4、晚上有四个人过桥，一次只能过两个人，但是只有一只手电筒，四个人过桥时间分别是1，2，5，8，求最短过桥时间？

假设这四人依次是甲乙丙丁：首先甲和乙过桥,甲带手电筒回来；然后丙和丁过桥,由乙带手电筒回来；最后甲再和乙一起过桥.所以最少用时间是2+1+8+2+2=15（分钟） 

5、两个容积分别为5升和6升的桶，最后如何只装3升？

第一步：先取来6升水，倒进5升桶的水桶里，即得到6升桶里余下的1升水；

第二步：把5L桶清掉，把取到的1升水放进5升的水桶里保留不动，然后再取6升水，倒进5升的水桶里，6升的桶得到的是2升水，把5L桶清掉，存放这2升水；

第三步：5升水桶有2升水．再取6升水，倒进5升水桶里，原有2L升+3升=5升，这时6升-3升=3升，6升里余下的就是3升水了。

6、井盖为什么是圆的？

井道大都是圆形的，所以井盖就做成圆形的。

很多井道都是圆形的，所以井盖自然也就是圆形的了。那为什么井大都是圆形的呢？因为建筑学和土木工程学中，圆形通道最有利于保持土壤的压力。

圆的受力更均匀不容易碎裂和塌陷

圆形井盖受力后，会向四周扩散压力，由于扩散均匀不容易碎裂和塌陷。
矩形的井盖由于受力不均匀，导致碎裂的几率远大于圆形。所以通过耐用性方面考虑还是圆形井盖合适。

圆形井盖从任何方向都不会掉落井下，也方便操作

矩形对角线的长度都大于矩形的长和宽。所以在对角线方向把井盖竖起来就容易掉落井下。

相对节省生成材料成本

相对于矩形或者正方形，矩形内切圆形的面积最小，生成用的材料也更少。

7、从前有座山，山脚下有5个海盗抢到了100枚金币，每一颗都一样的大小和价值。他们决定通过抽签的方式，按顺序提出分配方案决定金币的归属。 首先，由1号提出方案，5个人进行表决，半数人以上（包括半数）同意时，方案通过，否则他将被扔入大海喂鲨鱼，剩余海盗继续按顺序提出方案，依次类推。 假设每个海盗都是足够理性及机智，会考虑到利害及利益最大化问题，那么，1号海盗提出怎样的分配方案才能顺利通过考验并拿到可能性内最多的金币呢？

> 从后向前推，如果只剩4号和5号的话，5号一定会投反对票让4号喂鲨鱼，以独吞全部金币。所以，4号唯有支持3号才能保命。3号知道这一点，就会提(100，0，0)的分配方案，对4号、5号一毛不拔而将全部金币归为己有，因为他知道4号一无所获也会投赞成票，再加上自己一票他的方案即可通过。不过，2号推知到3号的方案，就会提出(98，0，1，1)的方案，即放弃3号，而给予4号和5号各一枚金币。由于该方案对于4号和5号来说比在3号分配时更为有利，他们将支持他而不希望由3号来分配。这样，2号将拿走98枚金币。不过，2号的方案会被1号所洞悉，1号并将提出(97，0，1，2，0)或(97，0，1，0，2)的方案，即放弃2号，而给3号一枚金币，同时给4号(或5号)2枚金币。由于1号的这一方案对于3号和4号(或5号)来说，相比2号分配时更优，他们将投1号的赞成票，再加上1号自己的票，1号的方案可获通过，97枚金币可轻松落入囊中。 













